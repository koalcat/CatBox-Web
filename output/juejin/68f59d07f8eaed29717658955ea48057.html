<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover"><meta name="google-site-verification" content="cCHsgG9ktuCTgWgYfqCJql8AeR4gAne4DTZqztPoirE"><meta name="apple-itunes-app" content="app-id=987739104"><meta name="baidu-site-verification" content="qiK2a1kcFc"><meta name="360-site-verification" content="4c3c7d57d59f0e1a308462fbc7fd7e51"><meta name="sogou_site_verification" content="c49WUDZczQ"><meta data-vue-meta="true" data-vmid="keywords" name="keywords" content="源码,后端,微信,数据库"><meta data-vue-meta="true" data-vmid="description" name="description" content="自我表扬：《Dubbo 实现原理与源码解析 —— 精品合集》 表扬自己：《D数据库实体设计合集》 摘要: 原创出处 http://www.iocoder.cn/RocketMQ/message-send-and-consume-orderly/ 「芋道源码」"><title data-vue-meta="true">分布式消息队列 RocketMQ 源码分析 —— Message 顺序发送与消费 - 后端 - 掘金</title><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/js/manifest.20254fa563d3539b68bf.js" as="script"><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/js/vendor.e6fd81aa1499049a5bee.js" as="script"><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/js/app.a99a1e8180beec940a3f.js" as="script"><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/css/app.37151bbb8a40894c7953daf9b02b2ff7.css" as="style"><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/js/3.f84ea6333e04793cc1e2.js" as="script"><link rel="apple-touch-icon" sizes="180x180" href="https://b-gold-cdn.xitu.io/favicons/v2/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon-16x16.png"><link rel="manifest" href="https://b-gold-cdn.xitu.io/favicons/v2/manifest.json"><link rel="mask-icon" href="https://b-gold-cdn.xitu.io/favicons/v2/safari-pinned-tab.svg" color="#5bbad5"><link rel="shortcut icon" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon.ico"><meta name="msapplication-config" content="https://b-gold-cdn.xitu.io/favicons/v2/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="search" title="掘金" href="https://b-gold-cdn.xitu.io/conf/search.xml" type="application/opensearchdescription+xml"><link rel="stylesheet" href="https://b-gold-cdn.xitu.io/ionicons/2.0.1/css/ionicons.min.css"><link rel="stylesheet" href="https://b-gold-cdn.xitu.io/asset/fw-icon/1.0.9/iconfont.css"><link href="https://b-gold-cdn.xitu.io/v3/static/css/app.37151bbb8a40894c7953daf9b02b2ff7.css" rel="stylesheet"><script async="" src="https://hm.baidu.com/hm.js?93bbd335a208870aa1f296bcd6842e5e"></script><script async="" src="//www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://assets.growingio.com/vds.js"></script><script type="text/javascript" charset="utf-8" async="" src="https://b-gold-cdn.xitu.io/v3/static/js/3.f84ea6333e04793cc1e2.js"></script></head><body><div id="juejin" data-v-6ede48a3=""><div class="global-component-box" data-v-6ede48a3=""><!----><div data-v-2840e9c3="" data-v-6ede48a3="" class="alert-list alert-list"></div><div data-v-6ddb54c6="" data-v-6ede48a3="" class="suspension-panel suspension-panel"><button data-v-6ddb54c6="" title="回到顶部" class="btn to-top-btn" style="display: none;"><i data-v-6ddb54c6="" class="ion-android-arrow-dropup"></i></button><button data-v-6ddb54c6="" title="建议反馈" class="btn meiqia-btn" style=""><i data-v-6ddb54c6="" class="ion-chatbubble-working"></i></button></div><!----><!----><div class="emoji-barrage" data-v-475389e2="" data-v-6ede48a3=""><!----></div><div class="book-new-user-award-popup" style="display: none;" data-v-7c95f01f="" data-v-6ede48a3=""><div class="content-box" style="display:;" data-v-7c95f01f=""><div class="close ion-close-round" data-v-7c95f01f=""></div><div class="header" data-v-7c95f01f=""><div class="icon" data-v-7c95f01f=""><img src="https://b-gold-cdn.xitu.io/v3/static/img/icon.a87e5ae.svg" data-v-7c95f01f=""></div><div class="txt" data-v-7c95f01f="">新人专享好礼</div></div><div class="desc" data-v-7c95f01f="">凡未购买过小册的用户，均可领取三张 5 折新人专享券，购买小册时自动使用专享券，最高可节省 45 元。</div><div class="tickets" data-v-7c95f01f=""><div class="ticket" data-v-7c95f01f=""><div class="ticket__inner" data-v-7c95f01f=""><div class="enjoy" data-v-7c95f01f=""><span class="new-title" data-v-7c95f01f="">小册新人 5 折券</span></div><div class="sale" data-v-7c95f01f="">最高可省 15 元</div></div></div><div class="ticket" data-v-7c95f01f=""><div class="ticket__inner" data-v-7c95f01f=""><div class="enjoy" data-v-7c95f01f=""><span class="new-title" data-v-7c95f01f="">小册新人 5 折券</span></div><div class="sale" data-v-7c95f01f="">最高可省 15 元</div></div></div><div class="ticket" data-v-7c95f01f=""><div class="ticket__inner" data-v-7c95f01f=""><div class="enjoy" data-v-7c95f01f=""><span class="new-title" data-v-7c95f01f="">小册新人 5 折券</span></div><div class="sale" data-v-7c95f01f="">最高可省 15 元</div></div></div></div><div class="remark" data-v-7c95f01f="">注：专享券的使用期限在领券的七天内。</div><div class="submit-btn" data-v-7c95f01f="">一键领取</div></div><div class="model success" style="display: none;" data-v-7c95f01f=""><div class="heading" data-v-7c95f01f="">领取成功</div><div class="content-text" data-v-7c95f01f="">购买小册时自动使用专享券</div><div class="btn-success-footer" data-v-7c95f01f=""><div class="btn-ok" data-v-7c95f01f="">知道了</div><div class="btn-ok btn-link" data-v-7c95f01f="">前往小册首页</div></div></div><div class="model fail" style="display: none;" data-v-7c95f01f=""><div class="heading" data-v-7c95f01f="">领取失败</div><div class="content-text" data-v-7c95f01f="">本活动仅适用于小册新用户</div><div class="btn-ok" data-v-7c95f01f="">知道了</div></div></div><!----></div><!----><div data-v-3f216172="" data-v-41d33d72="" data-v-6ede48a3="" class="view-container"><div data-v-3f216172="" class="main-header-box"><header data-v-5ce25e66="" data-v-3f216172="" class="main-header main-header unauthorized visible"><div data-v-5ce25e66="" class="container"><a data-v-5ce25e66="" href="/" class="logo"><img data-v-5ce25e66="" src="https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg" alt="掘金" class="logo-img"></a><nav data-v-5ce25e66="" role="navigation" class="main-nav"><ul data-v-5ce25e66="" class="nav-list"><li data-v-5ce25e66="" class="main-nav-list"><div data-v-5ce25e66="" class="phone-show-menu"><span data-v-5ce25e66="">首页</span><div data-v-5ce25e66="" class="icon ion-arrow-down-b"></div></div><ul data-v-5ce25e66="" class="phone-hide"><li data-v-5ce25e66="" class="nav-item link-item route-active"><a data-v-5ce25e66="" href="/">首页</a></li><li data-v-5ce25e66="" class="nav-item link-item pin"><a data-v-5ce25e66="" href="/pins">沸点</a><!----></li><li data-v-5ce25e66="" class="nav-item link-item book"><a data-v-5ce25e66="" href="/books">小册</a></li><li data-v-5ce25e66="" class="nav-item link-item"><a data-v-5ce25e66="" href="/repos">开源库</a></li><li data-v-5ce25e66="" class="nav-item link-item"><a data-v-5ce25e66="" href="/events/all">活动</a></li><li data-v-5ce25e66="" class="nav-item link-item conf"><a data-v-5ce25e66="" st:name="confGif" title="掘金开发者大会 · 微信小程序专场" target="_blank" href="https://conf.juejin.im/2018/mini-programs"><img data-v-5ce25e66="" src="https://b-gold-cdn.xitu.io/v3/static/img/conf.78960f5.gif" alt="掘金开发者大会 · 微信小程序专场" class="conf-icon"></a></li></ul></li><li data-v-5ce25e66="" class="nav-item search"><form data-v-5ce25e66="" role="search" class="search-form"><input data-v-5ce25e66="" maxlength="32" placeholder="搜索掘金" class="search-input"><img data-v-5ce25e66="" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjJweCIgaGVpZ2h0PSIyMnB4IiB2aWV3Qm94PSIwIDAgMjIgMjIiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogc2tldGNodG9vbCA0MS4yICgzNTM5NykgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Qjk3RUIxMEEtOEYzNC00QUI1LUFCQUYtNDFEOTMzNzQxRUQwPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBza2V0Y2h0b29sLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSLpppbpobUiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSLlr7zoiKrmoI/mkJzntKLmoYYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC05OTAuMDAwMDAwLCAtMTkuMDAwMDAwKSIgZmlsbD0iI0MzQ0NENSI+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTkwLjAwMDAwMCwgMTkuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuOTg2MTI2LDE0LjQwMDMzOTUgTDE2LjI5Mjg5MzIsMTcuNzA3MTA2OCBDMTYuNjgzNDE3NSwxOC4wOTc2MzExIDE3LjMxNjU4MjUsMTguMDk3NjMxMSAxNy43MDcxMDY4LDE3LjcwNzEwNjggQzE4LjA5NzYzMTEsMTcuMzE2NTgyNSAxOC4wOTc2MzExLDE2LjY4MzQxNzUgMTcuNzA3MTA2OCwxNi4yOTI4OTMyIEwxNC40MDAzMzk1LDEyLjk4NjEyNiBDMTUuOTYwMzg4MSwxMC43NTczMjk4IDE1Ljc0NTI0MDIsNy42NjQwMTk4MyAxMy43NTQ4OTU5LDUuNjczNjc1NTQgQzExLjUyMzMyODUsMy40NDIxMDgxNSA3LjkwNTI0MjkyLDMuNDQyMTA4MTUgNS42NzM2NzU1NCw1LjY3MzY3NTU0IEMzLjQ0MjEwODE1LDcuOTA1MjQyOTIgMy40NDIxMDgxNSwxMS41MjMzMjg1IDUuNjczNjc1NTQsMTMuNzU0ODk1OSBDNy42NjQwMTk4MywxNS43NDUyNDAyIDEwLjc1NzMyOTgsMTUuOTYwMzg4MSAxMi45ODYxMjYsMTQuNDAwMzM5NSBaIE03LjA4Nzg4OTEsMTIuMzQwNjgyMyBDNS42MzczNzAzLDEwLjg5MDE2MzUgNS42MzczNzAzLDguNTM4NDA3OSA3LjA4Nzg4OTEsNy4wODc4ODkxIEM4LjUzODQwNzksNS42MzczNzAzIDEwLjg5MDE2MzUsNS42MzczNzAzIDEyLjM0MDY4MjMsNy4wODc4ODkxIEMxMy43OTEyMDExLDguNTM4NDA3OSAxMy43OTEyMDExLDEwLjg5MDE2MzUgMTIuMzQwNjgyMywxMi4zNDA2ODIzIEMxMC44OTAxNjM1LDEzLjc5MTIwMTEgOC41Mzg0MDc5LDEzLjc5MTIwMTEgNy4wODc4ODkxLDEyLjM0MDY4MjMgWiIgaWQ9IkNvbWJpbmVkLVNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==" alt="搜索" class="search-icon"></form></li><!----><!----><!----><li data-v-5ce25e66="" class="nav-item submit"><img data-v-5ce25e66="" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjJweCIgaGVpZ2h0PSIyMnB4IiB2aWV3Qm94PSIwIDAgMjIgMjIiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogc2tldGNodG9vbCA0MiAoMzY3ODEpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPjA1Q0I0NzU5LUIyRkQtNDcxOC04RTBDLTg0OEVCNzQ2RDAyMzwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggc2tldGNodG9vbC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8cmVjdCBpZD0icGF0aC0xIiB4PSIyMzgiIHk9IjEyOCIgd2lkdGg9IjcwMCIgaGVpZ2h0PSI1MCIgcng9IjIiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci0yIj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd09mZnNldE91dGVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMSIgaW49InNoYWRvd09mZnNldE91dGVyMSIgcmVzdWx0PSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC4wNTAyNzE3MzkxIDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0JsdXJPdXRlcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0zIiB4PSI0IiB5PSI0IiB3aWR0aD0iMTMiIGhlaWdodD0iMTQiIHJ4PSIyIj48L3JlY3Q+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxMyIgaGVpZ2h0PSIxNCIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgIDwvZGVmcz4KICAgIDxnIGlkPSLpppbpobUiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSLpppbpobUyX0NvX+aZrumAmueUqOaItyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMwNS4wMDAwMDAsIC0xNDIuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSJDb21iaW5lZC1TaGFwZSI+CiAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMikiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0zMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzA1LjAwMDAwMCwgMTQyLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0zIiB4PSIwIiB5PSIwIiB3aWR0aD0iMjIiIGhlaWdodD0iMjIiPjwvcmVjdD4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik05Ljg5NTY2MjY1LDkuMzQ2Mjc4MzIgTDYuNjY3NTA3MzEsOS4zNDYyNzgzMiBDNi4zNzA1MDcxNyw5LjM0NjI3ODMyIDYuMTI5NDQ5ODQsOS4xMDI3MDQ4MiA2LjEyOTQ0OTg0LDguODAyNTc4MzYgQzYuMTI5NDQ5ODQsOC41MDI0NzMxNyA2LjM3MDUwNzE3LDguMjU4ODk5NjggNi42Njc1MDczMSw4LjI1ODg5OTY4IEw5Ljg5NTY4MzcxLDguMjU4ODk5NjggQzEwLjE5MjYyMDcsOC4yNTg4OTk2OCAxMC40MzM2NTcsOC41MDI0NzMxNyAxMC40MzM2NTcsOC44MDI1NzgzNiBDMTAuNDMzNjM1OSw5LjEwMjcwNDgyIDEwLjE5MjU5OTYsOS4zNDYyNzgzMiA5Ljg5NTY2MjY1LDkuMzQ2Mjc4MzIgTTEzLjExMzIzNzEsMTIuNjA4NDE0MiBMNi42NjY2OTgyLDEyLjYwODQxNDIgQzYuMzcwMTQ0NjcsMTIuNjA4NDE0MiA2LjEyOTQ0OTg0LDEyLjM2NTQwNTcgNi4xMjk0NDk4NCwxMi4wNjQ3NTY4IEM2LjEyOTQ0OTg0LDExLjc2NDAyMjkgNi4zNzAxNDQ2NywxMS41MjEwMzU2IDYuNjY2Njk4MiwxMS41MjEwMzU2IEwxMy4xMTMyMzcxLDExLjUyMTAzNTYgQzEzLjQxMDI3NDEsMTEuNTIxMDM1NiAxMy42NTA0ODU0LDExLjc2NDAyMjkgMTMuNjUwNDg1NCwxMi4wNjQ3NTY4IEMxMy42NTA0ODU0LDEyLjM2NTM4NDQgMTMuNDEwMjc0MSwxMi42MDg0MTQyIDEzLjExMzIzNzEsMTIuNjA4NDE0MiIgaWQ9Imljb25mb250LWJpYW5qaSIgZmlsbD0iIzAwN0ZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iUmVjdGFuZ2xlIiBzdHJva2U9IiMwMDdGRkYiIG1hc2s9InVybCgjbWFzay00KSIgc3Ryb2tlLXdpZHRoPSIyIiB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+" class="icon"><span data-v-5ce25e66="">写文章</span><!----></li><li data-v-5ce25e66="" class="nav-item auth"><span data-v-5ce25e66="" class="login">登录</span><span data-v-5ce25e66="" class="register">注册</span></li></ul></nav></div></header></div><main data-v-3f216172="" class="container main-container"><div data-v-41d33d72="" data-v-3f216172="" class="view entry-public-view"><div data-v-41d33d72="" data-v-3f216172="" class="entry-public-main shadow"><!----><!----><article data-v-41d33d72="" itemscope="itemscope" itemtype="http://schema.org/Article" class="entry-content-box" data-v-3f216172=""><meta itemprop="url" content="https://juejin.im/entry/5bccf701e51d457a26286d48"><meta itemprop="headline" content="分布式消息队列 RocketMQ 源码分析 —— Message 顺序发送与消费"><meta itemprop="keywords" content="源码,后端,微信,数据库"><meta itemprop="datePublished" content="2018-10-21T22:00:33.093Z"><meta itemprop="image" content="https://b-gold-cdn.xitu.io/icon/icon-128.png"><div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java公众号_芋道源码_每日更新"><meta itemprop="url" content="https://juejin.im/user/5904c637b123db3ee479d923"></div><div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"><div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://b-gold-cdn.xitu.io/icon/icon-white-180.png"><meta itemprop="width" content="180"><meta itemprop="height" content="180"></div></div><h1 data-v-41d33d72="">分布式消息队列 RocketMQ 源码分析 —— Message 顺序发送与消费</h1><div data-v-41d33d72="" class="entry-public-info"><div data-v-41d33d72="" class="text-muted info-item">阅读 1764</div><div data-v-41d33d72="" class="text-muted info-item">收藏 23</div><div data-v-41d33d72="" class="text-muted info-item">2018-10-22</div></div><div data-v-41d33d72="" class="originalUrl">原文链接：<a data-v-41d33d72="" st:name="originLink" href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%3Fjuejin%262018-10-22" rel="nofollow noopener noreferrer" target="_blank">www.iocoder.cn</a></div><a data-v-41d33d72="" class="banner" href="https://cloud.tencent.com/act/special/amd?fromSource=gwzcw.1351356.1351356.1351356" rel="nofollow noopener noreferrer" target="_blank"><span data-v-41d33d72="" class="text">AMD CPU云服务器全国首推</span><span data-v-41d33d72="" class="link">cloud.tencent.com</span></a><div data-v-41d33d72="" itemprop="articleBody" class="entry-content article-content"><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FDubbo%2Fgood-collection%2F%3Ftitle" target="_blank" rel="nofollow noopener noreferrer">自我表扬：《Dubbo 实现原理与源码解析 —— 精品合集》</a> <br> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FEntity%2Fgood-collection%2F%3Ftitle" target="_blank" rel="nofollow noopener noreferrer">表扬自己：《D数据库实体设计合集》</a>
<p>摘要: 原创出处 <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">www.iocoder.cn/RocketMQ/me…</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p>
<p><strong>本文主要基于 RocketMQ 4.0.x 正式版</strong> </p>
<ul>
    <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">1. 概述</a></li>
    <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">2. <code>Producer</code> 顺序发送</a></li>
    <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">3. <code>Consumer</code> 严格顺序消费</a>
        <ul>
            <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">3.1 获得(锁定)消息队列</a></li>
            <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">3.2 移除消息队列</a></li>
            <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">3.3 消费消息队列</a>
                <ul>
                    <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">3.1.1 消费消息</a></li>
                    <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">3.1.2 处理消费结果</a></li>
                    <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">3.13 消息处理队列核心方法</a></li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<hr>
<p><img alt="" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2018/10/18/166840b9b5db2e09?imageView2/0/w/1280/h/960/ignore-error/1" data-width="1280" data-height="536" src="https://user-gold-cdn.xitu.io/2018/10/18/166840b9b5db2e09?imageView2/0/w/1280/h/960/ignore-error/1"></p>
<blockquote>
    <p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利： </p>
    <ol>
        <li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表 </li>
        <li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong> </li>
        <li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。 </li>
        <li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。 </li>
        <li><strong>认真的</strong>源码交流微信群。</li>
    </ol>
</blockquote>
<hr>
<h1 id="1-概述" data-id="heading-0"><a href="#1-概述" title="1. 概述"></a>1. 概述</h1>
<p><strong>建议</strong>前置阅读内容：</p>
<ul>
    <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-receive%2F" target="_blank" rel="nofollow noopener noreferrer">《RocketMQ 源码分析 —— Message 发送与接收》</a></li>
    <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">《RocketMQ 源码分析 —— Message 拉取与消费（下）》</a></li>
</ul>
<p>当然对 <code>Message</code> 发送与消费已经有一定了解的同学，可以选择跳过。</p>
<hr>
<p><code>RocketMQ</code> 提供了两种顺序级别：</p>
<ul>
    <li>普通顺序消息 ：<code>Producer</code> 将相关联的消息发送到相同的消息队列。</li>
    <li>完全严格顺序 ：在 <code>普通顺序消息</code> 的基础上，<code>Consumer</code> 严格顺序消费。</li>
</ul>
<p>绝大部分场景下只需要用到<strong>普通顺序消息</strong>。<br>例如说：给用户发送短信消息 + 发送推送消息，将两条消息发送到不同的消息队列，若其中一条消息队列消费较慢造成堵塞，用户可能会收到两条消息会存在一定的时间差，带来的体验会相对较差。当然类似这种场景，即使有一定的时间差，<strong>不会产生系统逻辑上BUG</strong>。另外，<code>普通顺序消息</code>性能能更加好。<br>那么什么时候使用使用<strong>完全严格顺序</strong>？如下是来自官方文档的说明：</p>
<blockquote>
    <p>目前已知的应用只有数据库 <code>binlog</code> 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息</p>
</blockquote>
<hr>
<p>😈上代码！！！</p>
<h1 id="2-Producer-顺序发送" data-id="heading-1"><a href="#2-Producer-顺序发送" title="2. Producer 顺序发送"></a>2. <code>Producer</code> 顺序发送</h1>
<p>官方发送顺序消息的<strong>例子</strong>：</p>
<pre><code> 1: package org.apache.rocketmq.example.ordermessage;
 2: 
 3: import java.io.UnsupportedEncodingException;
 4: import java.util.List;
 5: import org.apache.rocketmq.client.exception.MQBrokerException;
 6: import org.apache.rocketmq.client.exception.MQClientException;
 7: import org.apache.rocketmq.client.producer.DefaultMQProducer;
 8: import org.apache.rocketmq.client.producer.MQProducer;
 9: import org.apache.rocketmq.client.producer.MessageQueueSelector;
10: import org.apache.rocketmq.client.producer.SendResult;
11: import org.apache.rocketmq.common.message.Message;
12: import org.apache.rocketmq.common.message.MessageQueue;
13: import org.apache.rocketmq.remoting.common.RemotingHelper;
14: import org.apache.rocketmq.remoting.exception.RemotingException;
15: 
16: public class Producer {
17:     public static void main(String[] args) throws UnsupportedEncodingException {
18:         try {
19:             MQProducer producer = new DefaultMQProducer("please_rename_unique_group_name");
20:             producer.start();
21: 
22:             String[] tags = new String[] {"TagA", "TagB", "TagC", "TagD", "TagE"};
23:             for (int i = 0; i &lt; 100; i++) {
24:                 int orderId = i % 10;
25:                 Message msg =
26:                     new Message("TopicTestjjj", tags[i % tags.length], "KEY" + i,
27:                         ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
28:                 SendResult sendResult = producer.send(msg, new MessageQueueSelector() {
29:                     @Override
30:                     public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) {
31:                         Integer id = (Integer) arg;
32:                         int index = id % mqs.size();
33:                         return mqs.get(index);
34:                     }
35:                 }, orderId);
36: 
37:                 System.out.printf("%s%n", sendResult);
38:             }
39: 
40:             producer.shutdown();
41:         } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {
42:             e.printStackTrace();
43:         }
44:     }
45: }
</code></pre>
<ul>
    <li>第 28 至 35 行 ：实现了根据 <code>id % mqs.size()</code> 来进行消息队列的选择。当前例子，我们传递 <code>orderId</code> 作为参数，那么相同的 <code>orderId</code> 能够进入相同的消息队列。</li>
</ul>
<hr>
<p><code>MessageQueueSelector</code> 接口的<strong>源码</strong>：</p>
<pre><code> 1: public interface MessageQueueSelector {
 2: 
 3:     /**
 4:      * 选择消息队列
 5:      *
 6:      * @param mqs 消息队列
 7:      * @param msg 消息
 8:      * @param arg 参数
 9:      * @return 消息队列
10:      */
11:     MessageQueue select(final List&lt;MessageQueue&gt; mqs, final Message msg, final Object arg);
12: }
</code></pre>
<hr>
<p><code>Producer</code> 选择队列发送消息方法的<strong>源码</strong>：</p>
<pre><code>16: private SendResult sendSelectImpl(//
17:     Message msg, //
18:     MessageQueueSelector selector, //
19:     Object arg, //
20:     final CommunicationMode communicationMode, //
21:     final SendCallback sendCallback, final long timeout//
22: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
23:     this.makeSureStateOK();
24:     Validators.checkMessage(msg, this.defaultMQProducer);
25: 
26:     TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());
27:     if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) {
28:         MessageQueue mq = null;
29:         try {
30:             mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);
31:         } catch (Throwable e) {
32:             throw new MQClientException("select message queue throwed exception.", e);
33:         }
34: 
35:         if (mq != null) {
36:             return this.sendKernelImpl(msg, mq, communicationMode, sendCallback, null, timeout);
37:         } else {
38:             throw new MQClientException("select message queue return null.", null);
39:         }
40:     }
41: 
42:     throw new MQClientException("No route info for this topic, " + msg.getTopic(), null);
43: }
</code></pre>
<ul>
    <li>第 30 行 ：选择消息队列。</li>
    <li>第 36 行 ：发送消息。</li>
</ul>
<h1 id="3-Consumer-严格顺序消费" data-id="heading-2"><a href="#3-Consumer-严格顺序消费" title="3. Consumer 严格顺序消费"></a>3. <code>Consumer</code> 严格顺序消费</h1>
<p><code>Consumer</code> 在严格顺序消费时，通过 <strong>三</strong> 把锁保证严格顺序消费。</p>
<ul>
    <li><code>Broker</code> 消息队列锁（<strong>分布式锁</strong>） ：
        <ul>
            <li>集群模式下，<code>Consumer</code> 从 <code>Broker</code> 获得该锁后，才能进行消息拉取、消费。</li>
            <li>广播模式下，<code>Consumer</code> 无需该锁。</li>
        </ul>
    </li>
    <li><code>Consumer</code> 消息队列锁（<strong>本地锁</strong>） ：<code>Consumer</code> 获得该锁才能操作消息队列。</li>
    <li><code>Consumer</code> 消息处理队列消费锁（<strong>本地锁</strong>） ：<code>Consumer</code> 获得该锁才能消费消息队列。</li>
</ul>
<p>可能同学有疑问，为什么有 <code>Consumer</code> 消息队列锁还需要有 <code>Consumer</code> 消息队列消费锁呢？😈让我们带着疑问继续往下看。</p>
<hr>
<h2 id="3-1-获得-锁定-消息队列" data-id="heading-3"><a href="#3-1-获得-锁定-消息队列" title="3.1 获得(锁定)消息队列"></a>3.1 获得(锁定)消息队列</h2>
<p><strong>集群模式</strong>下，<code>Consumer</code> 更新属于自己的消息队列时，会向 <code>Broker</code> 锁定该消息队列（<em>广播模式下不需要</em>）。如果锁定失败，则更新失败，即该消息队列不属于自己，不能进行消费。核心代码如下：</p>
<pre><code> 1: // ⬇️⬇️⬇️【RebalanceImpl.java】
 2: private boolean updateProcessQueueTableInRebalance(final String topic, final Set&lt;MessageQueue&gt; mqSet, final boolean isOrder) {
 3: // ..... 此处省略部分代码 
 4:     // 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列。
 5:     List&lt;PullRequest&gt; pullRequestList = new ArrayList&lt;&gt;(); // 拉消息请求数组
 6:     for (MessageQueue mq : mqSet) {
 7:         if (!this.processQueueTable.containsKey(mq)) {
 8:             if (isOrder &amp;&amp; !this.lock(mq)) { // 顺序消息锁定消息队列
 9:                 log.warn("doRebalance, {}, add a new mq failed, {}, because lock failed", consumerGroup, mq);
10:                 continue;
11:             }
12: 
13:             this.removeDirtyOffset(mq);
14:             ProcessQueue pq = new ProcessQueue();
15:             long nextOffset = this.computePullFromWhere(mq);
16:             if (nextOffset &gt;= 0) {
17:                 ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);
18:                 if (pre != null) {
19:                     log.info("doRebalance, {}, mq already exists, {}", consumerGroup, mq);
20:                 } else {
21:                     log.info("doRebalance, {}, add a new mq, {}", consumerGroup, mq);
22:                     PullRequest pullRequest = new PullRequest();
23:                     pullRequest.setConsumerGroup(consumerGroup);
24:                     pullRequest.setNextOffset(nextOffset);
25:                     pullRequest.setMessageQueue(mq);
26:                     pullRequest.setProcessQueue(pq);
27:                     pullRequestList.add(pullRequest);
28:                     changed = true;
29:                 }
30:             } else {
31:                 log.warn("doRebalance, {}, add new mq failed, {}", consumerGroup, mq);
32:             }
33:         }
34:     }
35: 
36: // ..... 此处省略部分代码 
37: }
38: 
39: // ⬇️⬇️⬇️【RebalanceImpl.java】
40: /**
41:  * 请求Broker获得指定消息队列的分布式锁
42:  *
43:  * @param mq 队列
44:  * @return 是否成功
45:  */
46: public boolean lock(final MessageQueue mq) {
47:     FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true);
48:     if (findBrokerResult != null) {
49:         LockBatchRequestBody requestBody = new LockBatchRequestBody();
50:         requestBody.setConsumerGroup(this.consumerGroup);
51:         requestBody.setClientId(this.mQClientFactory.getClientId());
52:         requestBody.getMqSet().add(mq);
53: 
54:         try {
55:             // 请求Broker获得指定消息队列的分布式锁
56:             Set&lt;MessageQueue&gt; lockedMq =
57:                 this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000);
58: 
59:             // 设置消息处理队列锁定成功。锁定消息队列成功，可能本地没有消息处理队列，设置锁定成功会在lockAll()方法。
60:             for (MessageQueue mmqq : lockedMq) {
61:                 ProcessQueue processQueue = this.processQueueTable.get(mmqq);
62:                 if (processQueue != null) {
63:                     processQueue.setLocked(true);
64:                     processQueue.setLastLockTimestamp(System.currentTimeMillis());
65:                 }
66:             }
67: 
68:             boolean lockOK = lockedMq.contains(mq);
69:             log.info("the message queue lock {}, {} {}",
70:                 lockOK ? "OK" : "Failed",
71:                 this.consumerGroup,
72:                 mq);
73:             return lockOK;
74:         } catch (Exception e) {
75:             log.error("lockBatchMQ exception, " + mq, e);
76:         }
77:     }
78: 
79:     return false;
80: }
</code></pre>
<ul>
    <li>⬆️⬆️⬆️</li>
    <li>第 8 至 11 行 ：顺序消费时，锁定消息队列。如果锁定失败，新增消息处理队列失败。</li>
</ul>
<hr>
<p><code>Broker</code> 消息队列锁会过期，默认配置 30s。因此，<code>Consumer</code> 需要不断向 <code>Broker</code> 刷新该锁过期时间，默认配置 20s 刷新一次。核心代码如下：</p>
<pre><code> 1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】
 2: public void start() {
 3:     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())) {
 4:         this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
 5:             @Override
 6:             public void run() {
 7:                 ConsumeMessageOrderlyService.this.lockMQPeriodically();
 8:             }
 9:         }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);
10:     }
11: }
</code></pre>
<h2 id="3-2-移除消息队列" data-id="heading-4"><a href="#3-2-移除消息队列" title="3.2 移除消息队列"></a>3.2 移除消息队列</h2>
<p>集群模式下，<code>Consumer</code> 移除自己的消息队列时，会向 <code>Broker</code> 解锁该消息队列（广播模式下不需要）。核心代码如下：</p>
<pre><code> 1: // ⬇️⬇️⬇️【RebalancePushImpl.java】
 2: /**
 3:  * 移除不需要的队列相关的信息
 4:  * 1. 持久化消费进度，并移除之
 5:  * 2. 顺序消费&amp;集群模式，解锁对该队列的锁定
 6:  *
 7:  * @param mq 消息队列
 8:  * @param pq 消息处理队列
 9:  * @return 是否移除成功
10:  */
11: @Override
12: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {
13:     // 同步队列的消费进度，并移除之。
14:     this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);
15:     this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);
16:     // 集群模式下，顺序消费移除时，解锁对队列的锁定
17:     if (this.defaultMQPushConsumerImpl.isConsumeOrderly()
18:         &amp;&amp; MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
19:         try {
20:             if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) {
21:                 try {
22:                     return this.unlockDelay(mq, pq);
23:                 } finally {
24:                     pq.getLockConsume().unlock();
25:                 }
26:             } else {
27:                 log.warn("[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}", //
28:                     mq, //
29:                     pq.getTryUnlockTimes());
30: 
31:                 pq.incTryUnlockTimes();
32:             }
33:         } catch (Exception e) {
34:             log.error("removeUnnecessaryMessageQueue Exception", e);
35:         }
36: 
37:         return false;
38:     }
39:     return true;
40: }
41: 
42: // ⬇️⬇️⬇️【RebalancePushImpl.java】
43: /**
44:  * 延迟解锁 Broker 消息队列锁
45:  * 当消息处理队列不存在消息，则直接解锁
46:  *
47:  * @param mq 消息队列
48:  * @param pq 消息处理队列
49:  * @return 是否解锁成功
50:  */
51: private boolean unlockDelay(final MessageQueue mq, final ProcessQueue pq) {
52:     if (pq.hasTempMessage()) { // TODO 疑问：为什么要延迟移除
53:         log.info("[{}]unlockDelay, begin {} ", mq.hashCode(), mq);
54:         this.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(new Runnable() {
55:             @Override
56:             public void run() {
57:                 log.info("[{}]unlockDelay, execute at once {}", mq.hashCode(), mq);
58:                 RebalancePushImpl.this.unlock(mq, true);
59:             }
60:         }, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS);
61:     } else {
62:         this.unlock(mq, true);
63:     }
64:     return true;
65: }
</code></pre>
<ul>
    <li>⬆️⬆️⬆️</li>
    <li>第 20 至 32 行 ：获取<strong>消息队列消费锁</strong>，避免和消息队列消费冲突。如果获取锁失败，则移除消息队列失败，等待下次重新分配消费队列时，再进行移除。如果未获得锁而进行移除，则可能出现另外的 <code>Consumer</code> 和当前 <code>Consumer</code> 同时消费该消息队列，导致消息无法严格顺序消费。</li>
    <li>第 51 至 64 行 ：解锁 <code>Broker</code> 消息队列锁。如果消息处理队列存在剩余消息，则延迟解锁 <code>Broker</code> 消息队列锁。❓为什么消息处理队列存在剩余消息不能直接解锁呢？😈我也不知道，百思不得其解。如果有知道的同学麻烦教育下俺。</li>
</ul>
<h2 id="3-3-消费消息队列" data-id="heading-5"><a href="#3-3-消费消息队列" title="3.3 消费消息队列"></a>3.3 消费消息队列</h2>
<p>😏本节会类比<strong>并发消费消费队列</strong>，建议对照 <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F%236%E3%80%81PushConsumer-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF" target="_blank" rel="nofollow noopener noreferrer">PushConsumer并发消费消息</a> 一起理解。</p>
<h3 id="3-1-1-消费消息" data-id="heading-6"><a href="#3-1-1-消费消息" title="3.1.1 消费消息"></a>3.1.1 消费消息</h3>
<p><img alt="顺序消费活动图-消费消息" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/10/22/16698a51011c8359?imageView2/0/w/1280/h/960/ignore-error/1" data-width="1280" data-height="1001" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;1001&quot;&gt;&lt;/svg&gt;"></p>
<pre><code>  1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】
  2: class ConsumeRequest implements Runnable {
  3: 
  4:     /**
  5:      * 消息处理队列
  6:      */
  7:     private final ProcessQueue processQueue;
  8:     /**
  9:      * 消息队列
 10:      */
 11:     private final MessageQueue messageQueue;
 12: 
 13:     @Override
 14:     public void run() {
 15:         if (this.processQueue.isDropped()) {
 16:             log.warn("run, the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
 17:             return;
 18:         }
 19: 
 20:         // 获得 Consumer 消息队列锁
 21:         final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue);
 22:         synchronized (objLock) {
 23:             // (广播模式) 或者 (集群模式 &amp;&amp; Broker消息队列锁有效)
 24:             if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
 25:                 || (this.processQueue.isLocked() &amp;&amp; !this.processQueue.isLockExpired())) {
 26:                 final long beginTime = System.currentTimeMillis();
 27:                 // 循环
 28:                 for (boolean continueConsume = true; continueConsume; ) {
 29:                     if (this.processQueue.isDropped()) {
 30:                         log.warn("the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
 31:                         break;
 32:                     }
 33: 
 34:                     // 消息队列分布式锁未锁定，提交延迟获得锁并消费请求
 35:                     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
 36:                         &amp;&amp; !this.processQueue.isLocked()) {
 37:                         log.warn("the message queue not locked, so consume later, {}", this.messageQueue);
 38:                         ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
 39:                         break;
 40:                     }
 41:                     // 消息队列分布式锁已经过期，提交延迟获得锁并消费请求
 42:                     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
 43:                         &amp;&amp; this.processQueue.isLockExpired()) {
 44:                         log.warn("the message queue lock expired, so consume later, {}", this.messageQueue);
 45:                         ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
 46:                         break;
 47:                     }
 48: 
 49:                     // 当前周期消费时间超过连续时长，默认：60s，提交延迟消费请求。默认情况下，每消费1分钟休息10ms。
 50:                     long interval = System.currentTimeMillis() - beginTime;
 51:                     if (interval &gt; MAX_TIME_CONSUME_CONTINUOUSLY) {
 52:                         ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10);
 53:                         break;
 54:                     }
 55: 
 56:                     // 获取消费消息。此处和并发消息请求不同，并发消息请求已经带了消费哪些消息。
 57:                     final int consumeBatchSize = ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();
 58:                     List&lt;MessageExt&gt; msgs = this.processQueue.takeMessags(consumeBatchSize);
 59:                     if (!msgs.isEmpty()) {
 60:                         final ConsumeOrderlyContext context = new ConsumeOrderlyContext(this.messageQueue);
 61: 
 62:                         ConsumeOrderlyStatus status = null;
 63: 
 64:                         // ....省略代码：Hook：before
 65: 
 66:                         // 执行消费
 67:                         long beginTimestamp = System.currentTimeMillis();
 68:                         ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;
 69:                         boolean hasException = false;
 70:                         try {
 71:                             this.processQueue.getLockConsume().lock(); // 锁定队列消费锁
 72: 
 73:                             if (this.processQueue.isDropped()) {
 74:                                 log.warn("consumeMessage, the message queue not be able to consume, because it's dropped. {}",
 75:                                     this.messageQueue);
 76:                                 break;
 77:                             }
 78: 
 79:                             status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);
 80:                         } catch (Throwable e) {
 81:                             log.warn("consumeMessage exception: {} Group: {} Msgs: {} MQ: {}", //
 82:                                 RemotingHelper.exceptionSimpleDesc(e), //
 83:                                 ConsumeMessageOrderlyService.this.consumerGroup, //
 84:                                 msgs, //
 85:                                 messageQueue);
 86:                             hasException = true;
 87:                         } finally {
 88:                             this.processQueue.getLockConsume().unlock(); // 锁定队列消费锁
 89:                         }
 90: 
 91:                         // ....省略代码：解析消费结果状态
 92: 
 93:                         // ....省略代码：Hook：after
 94: 
 95:                         ConsumeMessageOrderlyService.this.getConsumerStatsManager()
 96:                             .incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);
 97: 
 98:                         // 处理消费结果
 99:                         continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this);
100:                     } else {
101:                         continueConsume = false;
102:                     }
103:                 }
104:             } else {
105:                 if (this.processQueue.isDropped()) {
106:                     log.warn("the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
107:                     return;
108:                 }
109: 
110:                 ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100);
111:             }
112:         }
113:     }
114: 
115: }
</code></pre>
<ul>
    <li>⬆️⬆️⬆️</li>
    <li>第 20 行 ：获得 <code>Consumer</code> 消息队列锁。</li>
    <li>第 58 行 ：从消息处理队列顺序获得消息。<strong>和并发消费获得消息不同。并发消费请求在请求创建时，已经设置好消费哪些消息。</strong></li>
    <li>第 71 行 ：获得 <code>Consumer</code> 消息处理队列消费锁。相比【<code>Consumer</code>消息队列锁】，其粒度较小。这就是上文提到的❓为什么有<code>Consumer</code>消息队列锁还需要有 Consumer 消息队列消费锁呢的原因。</li>
    <li>第 79 行 ：<strong>执行消费</strong>。</li>
    <li>第 99 行 ：处理消费结果。</li>
</ul>
<h3 id="3-1-2-处理消费结果" data-id="heading-7"><a href="#3-1-2-处理消费结果" title="3.1.2 处理消费结果"></a>3.1.2 处理消费结果</h3>
<p>顺序消费消息结果 (<code>ConsumeOrderlyStatus</code>) 有四种情况：</p>
<ul>
    <li><code>SUCCESS</code> ：消费成功<strong>但不提交</strong>。</li>
    <li><code>ROLLBACK</code> ：消费失败，消费回滚。</li>
    <li><code>COMMIT</code> ：消费成功提交并且提交。</li>
    <li><code>SUSPEND_CURRENT_QUEUE_A_MOMENT</code> ：消费失败，挂起消费队列一会会，稍后继续消费。</li>
</ul>
<p>考虑到 <code>ROLLBACK</code> 、<code>COMMIT</code> 暂时只使用在 <code>MySQL binlog</code> 场景，官方将这两状态标记为 <code>@Deprecated</code>。当然，相应的实现逻辑依然保留。</p>
<p>在<strong>并发消费</strong>场景时，如果消费失败，<code>Consumer</code> 会将消费失败消息发回到 <code>Broker</code> 重试队列，跳过当前消息，等待下次拉取该消息再进行消费。</p>
<p>但是在<strong>完全严格顺序消费</strong>消费时，这样做显然不行。也因此，消费失败的消息，会挂起队列一会会，稍后继续消费。 </p>
<p>不过消费失败的消息一直失败，也不可能一直消费。当超过消费重试上限时，<code>Consumer</code> 会将消费失败超过上限的消息发回到 <code>Broker</code> 死信队列。</p>
<p>让我们来看看代码：</p>
<pre><code>  1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】
  2: /**
  3:  * 处理消费结果，并返回是否继续消费
  4:  *
  5:  * @param msgs 消息
  6:  * @param status 消费结果状态
  7:  * @param context 消费Context
  8:  * @param consumeRequest 消费请求
  9:  * @return 是否继续消费
 10:  */
 11: public boolean processConsumeResult(//
 12:     final List&lt;MessageExt&gt; msgs, //
 13:     final ConsumeOrderlyStatus status, //
 14:     final ConsumeOrderlyContext context, //
 15:     final ConsumeRequest consumeRequest//
 16: ) {
 17:     boolean continueConsume = true;
 18:     long commitOffset = -1L;
 19:     if (context.isAutoCommit()) {
 20:         switch (status) {
 21:             case COMMIT:
 22:             case ROLLBACK:
 23:                 log.warn("the message queue consume result is illegal, we think you want to ack these message {}", consumeRequest.getMessageQueue());
 24:             case SUCCESS:
 25:                 // 提交消息已消费成功到消息处理队列
 26:                 commitOffset = consumeRequest.getProcessQueue().commit();
 27:                 // 统计
 28:                 this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
 29:                 break;
 30:             case SUSPEND_CURRENT_QUEUE_A_MOMENT:
 31:                 // 统计
 32:                 this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
 33:                 if (checkReconsumeTimes(msgs)) { // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms
 34:                     // 设置消息重新消费
 35:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);
 36:                     // 提交延迟消费请求
 37:                     this.submitConsumeRequestLater(//
 38:                         consumeRequest.getProcessQueue(), //
 39:                         consumeRequest.getMessageQueue(), //
 40:                         context.getSuspendCurrentQueueTimeMillis());
 41:                     continueConsume = false;
 42:                 } else {
 43:                     commitOffset = consumeRequest.getProcessQueue().commit();
 44:                 }
 45:                 break;
 46:             default:
 47:                 break;
 48:         }
 49:     } else {
 50:         switch (status) {
 51:             case SUCCESS:
 52:                 this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
 53:                 break;
 54:             case COMMIT:
 55:                 // 提交消息已消费成功到消息处理队列
 56:                 commitOffset = consumeRequest.getProcessQueue().commit();
 57:                 break;
 58:             case ROLLBACK:
 59:                 // 设置消息重新消费
 60:                 consumeRequest.getProcessQueue().rollback();
 61:                 this.submitConsumeRequestLater(//
 62:                     consumeRequest.getProcessQueue(), //
 63:                     consumeRequest.getMessageQueue(), //
 64:                     context.getSuspendCurrentQueueTimeMillis());
 65:                 continueConsume = false;
 66:                 break;
 67:             case SUSPEND_CURRENT_QUEUE_A_MOMENT: // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms
 68:                 this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
 69:                 if (checkReconsumeTimes(msgs)) {
 70:                     // 设置消息重新消费
 71:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);
 72:                     // 提交延迟消费请求
 73:                     this.submitConsumeRequestLater(//
 74:                         consumeRequest.getProcessQueue(), //
 75:                         consumeRequest.getMessageQueue(), //
 76:                         context.getSuspendCurrentQueueTimeMillis());
 77:                     continueConsume = false;
 78:                 }
 79:                 break;
 80:             default:
 81:                 break;
 82:         }
 83:     }
 84: 
 85:     // 消息处理队列未dropped，提交有效消费进度
 86:     if (commitOffset &gt;= 0 &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) {
 87:         this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, false);
 88:     }
 89: 
 90:     return continueConsume;
 91: }
 92: 
 93: private int getMaxReconsumeTimes() {
 94:     // default reconsume times: Integer.MAX_VALUE
 95:     if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {
 96:         return Integer.MAX_VALUE;
 97:     } else {
 98:         return this.defaultMQPushConsumer.getMaxReconsumeTimes();
 99:     }
100: }
101: 
102: /**
103:  * 计算是否要暂停消费
104:  * 不暂停条件：存在消息都超过最大消费次数并且都发回broker成功
105:  *
106:  * @param msgs 消息
107:  * @return 是否要暂停
108:  */
109: private boolean checkReconsumeTimes(List&lt;MessageExt&gt; msgs) {
110:     boolean suspend = false;
111:     if (msgs != null &amp;&amp; !msgs.isEmpty()) {
112:         for (MessageExt msg : msgs) {
113:             if (msg.getReconsumeTimes() &gt;= getMaxReconsumeTimes()) {
114:                 MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));
115:                 if (!sendMessageBack(msg)) { // 发回失败，中断
116:                     suspend = true;
117:                     msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
118:                 }
119:             } else {
120:                 suspend = true;
121:                 msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
122:             }
123:         }
124:     }
125:     return suspend;
126: }
127: 
128: /**
129:  * 发回消息。
130:  * 消息发回broker后，对应的消息队列是死信队列。
131:  *
132:  * @param msg 消息
133:  * @return 是否发送成功
134:  */
135: public boolean sendMessageBack(final MessageExt msg) {
136:     try {
137:         // max reconsume times exceeded then send to dead letter queue.
138:         Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());
139:         String originMsgId = MessageAccessor.getOriginMessageId(msg);
140:         MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);
141:         newMsg.setFlag(msg.getFlag());
142:         MessageAccessor.setProperties(newMsg, msg.getProperties());
143:         MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());
144:         MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes()));
145:         MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));
146:         newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());
147: 
148:         this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg);
149:         return true;
150:     } catch (Exception e) {
151:         log.error("sendMessageBack exception, group: " + this.consumerGroup + " msg: " + msg.toString(), e);
152:     }
153: 
154:     return false;
155: }
</code></pre>
<ul>
    <li>⬆️⬆️⬆️</li>
    <li>第 21 至 29 行 ：消费成功。在自动提交进度( <code>AutoCommit</code> )的情况下，<code>COMMIT</code>、<code>ROLLBACK</code>、<code>SUCCESS</code> 逻辑<strong>已经统一</strong>。</li>
    <li>第 30 至 45 行 ：消费失败。当消息重试次数超过上限（默认 ：16次）时，将消息发送到 <code>Broker</code> 死信队列，跳过这些消息。此时，消息队列无需挂起，继续消费后面的消息。</li>
    <li>第 85 至 88 行 ：提交消费进度。</li>
</ul>
<h3 id="3-13-消息处理队列核心方法" data-id="heading-8"><a href="#3-13-消息处理队列核心方法" title="3.13 消息处理队列核心方法"></a>3.13 消息处理队列核心方法</h3>
<p>😈涉及到的四个核心方法的源码：</p>
<pre><code>  1: // ⬇️⬇️⬇️【ProcessQueue.java】
  2: /**
  3:  * 消息映射
  4:  * key：消息队列位置
  5:  */
  6: private final TreeMap&lt;Long, MessageExt&gt; msgTreeMap = new TreeMap&lt;&gt;();    /**
  7:  * 消息映射临时存储（消费中的消息）
  8:  */
  9: private final TreeMap&lt;Long, MessageExt&gt; msgTreeMapTemp = new TreeMap&lt;&gt;();
 10: 
 11: /**
 12:  * 回滚消费中的消息
 13:  * 逻辑类似于{@link #makeMessageToCosumeAgain(List)}
 14:  */
 15: public void rollback() {
 16:     try {
 17:         this.lockTreeMap.writeLock().lockInterruptibly();
 18:         try {
 19:             this.msgTreeMap.putAll(this.msgTreeMapTemp);
 20:             this.msgTreeMapTemp.clear();
 21:         } finally {
 22:             this.lockTreeMap.writeLock().unlock();
 23:         }
 24:     } catch (InterruptedException e) {
 25:         log.error("rollback exception", e);
 26:     }
 27: }
 28: 
 29: /**
 30:  * 提交消费中的消息已消费成功，返回消费进度
 31:  *
 32:  * @return 消费进度
 33:  */
 34: public long commit() {
 35:     try {
 36:         this.lockTreeMap.writeLock().lockInterruptibly();
 37:         try {
 38:             // 消费进度
 39:             Long offset = this.msgTreeMapTemp.lastKey();
 40: 
 41:             //
 42:             msgCount.addAndGet(this.msgTreeMapTemp.size() * (-1));
 43: 
 44:             //
 45:             this.msgTreeMapTemp.clear();
 46: 
 47:             // 返回消费进度
 48:             if (offset != null) {
 49:                 return offset + 1;
 50:             }
 51:         } finally {
 52:             this.lockTreeMap.writeLock().unlock();
 53:         }
 54:     } catch (InterruptedException e) {
 55:         log.error("commit exception", e);
 56:     }
 57: 
 58:     return -1;
 59: }
 60: 
 61: /**
 62:  * 指定消息重新消费
 63:  * 逻辑类似于{@link #rollback()}
 64:  *
 65:  * @param msgs 消息
 66:  */
 67: public void makeMessageToCosumeAgain(List&lt;MessageExt&gt; msgs) {
 68:     try {
 69:         this.lockTreeMap.writeLock().lockInterruptibly();
 70:         try {
 71:             for (MessageExt msg : msgs) {
 72:                 this.msgTreeMapTemp.remove(msg.getQueueOffset());
 73:                 this.msgTreeMap.put(msg.getQueueOffset(), msg);
 74:             }
 75:         } finally {
 76:             this.lockTreeMap.writeLock().unlock();
 77:         }
 78:     } catch (InterruptedException e) {
 79:         log.error("makeMessageToCosumeAgain exception", e);
 80:     }
 81: }
 82: 
 83: /**
 84:  * 获得持有消息前N条
 85:  *
 86:  * @param batchSize 条数
 87:  * @return 消息
 88:  */
 89: public List&lt;MessageExt&gt; takeMessags(final int batchSize) {
 90:     List&lt;MessageExt&gt; result = new ArrayList&lt;&gt;(batchSize);
 91:     final long now = System.currentTimeMillis();
 92:     try {
 93:         this.lockTreeMap.writeLock().lockInterruptibly();
 94:         this.lastConsumeTimestamp = now;
 95:         try {
 96:             if (!this.msgTreeMap.isEmpty()) {
 97:                 for (int i = 0; i &lt; batchSize; i++) {
 98:                     Map.Entry&lt;Long, MessageExt&gt; entry = this.msgTreeMap.pollFirstEntry();
 99:                     if (entry != null) {
100:                         result.add(entry.getValue());
101:                         msgTreeMapTemp.put(entry.getKey(), entry.getValue());
102:                     } else {
103:                         break;
104:                     }
105:                 }
106:             }
107: 
108:             if (result.isEmpty()) {
109:                 consuming = false;
110:             }
111:         } finally {
112:             this.lockTreeMap.writeLock().unlock();
113:         }
114:     } catch (InterruptedException e) {
115:         log.error("take Messages exception", e);
116:     }
117: 
118:     return result;
119: }
</code></pre>
<h1 id="666-彩蛋" data-id="heading-9"><a href="#666-彩蛋" title="666. 彩蛋"></a>666. 彩蛋</h1>
<p><img alt="知识星球" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/10/18/166840b9e1e4b9c1?imageView2/0/w/1280/h/960/ignore-error/1" data-width="987" data-height="555" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;987&quot; height=&quot;555&quot;&gt;&lt;/svg&gt;"></p></div><div data-v-41d33d72="" class="footer"><ul data-v-41d33d72="" class="tag-list"><li data-v-41d33d72="" class="item"><a data-v-41d33d72="" href="/tag/%E6%BA%90%E7%A0%81" class="">源码</a></li><li data-v-41d33d72="" class="item"><a data-v-41d33d72="" href="/tag/%E5%90%8E%E7%AB%AF" class="">后端</a></li><li data-v-41d33d72="" class="item"><a data-v-41d33d72="" href="/tag/%E5%BE%AE%E4%BF%A1" class="">微信</a></li><li data-v-41d33d72="" class="item"><a data-v-41d33d72="" href="/tag/%E6%95%B0%E6%8D%AE%E5%BA%93" class="">数据库</a></li></ul><section data-v-41d33d72=""><div data-v-a0f279e6="" data-v-41d33d72="" class="wechat-banner wechat-banner"><img data-v-a0f279e6="" src="https://b-gold-cdn.xitu.io/v3/static/img/backend.58ef824.png" class="wechat-img"></div></section><!----><div data-v-41d33d72="" class="related-entry-list-box"><div data-v-41d33d72="" class="title">相关热门文章</div><ul data-v-41d33d72="" class="related-entry-list"><li data-v-41d33d72="" class="item"><div data-v-9db545a6="" data-v-41d33d72="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-9db545a6="" href="/post/5bcd19fbe51d457a964d08d7" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-9db545a6="" data-src="https://user-gold-cdn.xitu.io/2018/10/22/166992e6a299bda1?imageView2/1/q/85/interlace/1" class="lazy thumb thumb loaded" style="background-image: url(https://user-gold-cdn.xitu.io/2018/10/22/166992e6a299bda1?imageView2/1/q/85/interlace/1); background-size: cover;"></div><div data-v-9db545a6="" class="info"><div data-v-9db545a6="" class="row title-row"><span data-v-9db545a6="" class="title">看图轻松理解数据结构与算法系列(红黑树)</span></div><div data-v-9db545a6="" class="row meta-row"><ul data-v-9db545a6="" class="meta-list"><li data-v-9db545a6="" class="meta user"><div data-v-9db545a6="" class="username">超人汪小建</div></li><li data-v-9db545a6="" class="meta like"><div data-v-9db545a6="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-9db545a6="" class="count">28</div></li><li data-v-9db545a6="" class="meta comment"><div data-v-9db545a6="" class="icon icon-comments iconfont icon-xlchatbox"></div><div data-v-9db545a6="" class="count">2</div></li></ul></div></div></a></div></li><li data-v-41d33d72="" class="item"><div data-v-9db545a6="" data-v-41d33d72="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-9db545a6="" href="/post/5bc7067c6fb9a05d1117b2ef" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-9db545a6="" data-src="https://user-gold-cdn.xitu.io/2018/10/17/1668182dda1ee6b2?imageView2/1/q/85/interlace/1" class="lazy thumb thumb loaded" style="background-image: url(https://user-gold-cdn.xitu.io/2018/10/17/1668182dda1ee6b2?imageView2/1/q/85/interlace/1); background-size: cover;"></div><div data-v-9db545a6="" class="info"><div data-v-9db545a6="" class="row title-row"><span data-v-9db545a6="" class="title">掘金直播 第十一期小程序专场  打码指南：由猫眼线下扫码1分购谈起</span></div><div data-v-9db545a6="" class="row meta-row"><ul data-v-9db545a6="" class="meta-list"><li data-v-9db545a6="" class="meta user"><div data-v-9db545a6="" class="username">掘金直播</div></li><li data-v-9db545a6="" class="meta like"><div data-v-9db545a6="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-9db545a6="" class="count">5</div></li><!----></ul></div></div></a></div></li><li data-v-41d33d72="" class="item"><div data-v-9db545a6="" data-v-41d33d72="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-9db545a6="" href="/post/5bcd157b6fb9a05d0b146ef7" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-9db545a6="" data-src="https://user-gold-cdn.xitu.io/2018/10/22/166991cc3e7465f9?imageView2/1/q/85/interlace/1" class="lazy thumb thumb loaded" style="background-image: url(https://user-gold-cdn.xitu.io/2018/10/22/166991cc3e7465f9?imageView2/1/q/85/interlace/1); background-size: cover;"></div><div data-v-9db545a6="" class="info"><div data-v-9db545a6="" class="row title-row"><span data-v-9db545a6="" class="title">利用责任链模式设计一个拦截器</span></div><div data-v-9db545a6="" class="row meta-row"><ul data-v-9db545a6="" class="meta-list"><li data-v-9db545a6="" class="meta user"><div data-v-9db545a6="" class="username">crossoverJie</div></li><li data-v-9db545a6="" class="meta like"><div data-v-9db545a6="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-9db545a6="" class="count">19</div></li><li data-v-9db545a6="" class="meta comment"><div data-v-9db545a6="" class="icon icon-comments iconfont icon-xlchatbox"></div><div data-v-9db545a6="" class="count">2</div></li></ul></div></div></a></div></li><li data-v-41d33d72="" class="item"><div data-v-9db545a6="" data-v-41d33d72="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-9db545a6="" href="/post/5bcd2022f265da0abe273330" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-9db545a6="" data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAACgBAMAAACPjaivAAAAElBMVEXi6O3////R3ujj6e/c5u3X4usQB3wbAAABCElEQVR42u3Vy03FQBBE0U6BDBCfPSEQAvlHw44FmvaoEbJLz+dGcORWeUqSJEmSJEmS/trTphoGCAi4CRAQcNMtgfUrQMDjbjgSQMBJgIDTjgyAj3JiQMBJtwTG/2bigfEnBgScdEtg/G8mHhh/YkDASYCAgJsAAQE3AQICbgIEBNwECPgvwJef3mrY2cCvGnY28KOGnQx8rcs7Btb1LYE5E2mAORNpgEEXXgNzJtIAgz7gGpgzkQaYM5EGmPKKtMCciRwBPyuiFvheGS2BQRdeA3Mm0gOfK6QlMGciDTBnIg0w6MJrYM5EGmDQB1wDcybSAHMm0gBTXpEWmDMRSZIkSZIk6cK+AUdTxLnCoi0gAAAAAElFTkSuQmCC" class="lazy thumb thumb loaded" style="background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAACgBAMAAACPjaivAAAAElBMVEXi6O3////R3ujj6e/c5u3X4usQB3wbAAABCElEQVR42u3Vy03FQBBE0U6BDBCfPSEQAvlHw44FmvaoEbJLz+dGcORWeUqSJEmSJEmS/trTphoGCAi4CRAQcNMtgfUrQMDjbjgSQMBJgIDTjgyAj3JiQMBJtwTG/2bigfEnBgScdEtg/G8mHhh/YkDASYCAgJsAAQE3AQICbgIEBNwECPgvwJef3mrY2cCvGnY28KOGnQx8rcs7Btb1LYE5E2mAORNpgEEXXgNzJtIAgz7gGpgzkQaYM5EGmPKKtMCciRwBPyuiFvheGS2BQRdeA3Mm0gOfK6QlMGciDTBnIg0w6MJrYM5EGmDQB1wDcybSAHMm0gBTXpEWmDMRSZIkSZIk6cK+AUdTxLnCoi0gAAAAAElFTkSuQmCC); background-size: cover;"></div><div data-v-9db545a6="" class="info"><div data-v-9db545a6="" class="row title-row"><span data-v-9db545a6="" class="title">Go语言性能优化- For Range 性能研究</span></div><div data-v-9db545a6="" class="row meta-row"><ul data-v-9db545a6="" class="meta-list"><li data-v-9db545a6="" class="meta user"><div data-v-9db545a6="" class="username">飞雪无情</div></li><li data-v-9db545a6="" class="meta like"><div data-v-9db545a6="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-9db545a6="" class="count">8</div></li><!----></ul></div></div></a></div></li></ul></div></div></article><div data-v-4f97d566="" data-v-41d33d72="" class="comment-list-box" id="comment-box" data-v-3f216172=""><div data-v-4f97d566="" class="title">评论</div><div data-v-1cbbd4f0="" data-v-4f97d566="" class="comment-form comment-form"><div data-v-1cbbd4f0="" class="avatar-box"><div data-v-b2db8566="" data-v-1b9df826="" data-v-1cbbd4f0="" data-src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjM2cHgiIGhlaWdodD0iMzZweCIgdmlld0JveD0iMCAwIDM2IDM2IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOnNrZXRjaD0iaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zIj4KICAgIDwhLS0gR2VuZXJhdG9yOiBTa2V0Y2ggMy4zLjMgKDEyMDgxKSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5kZWZhdWx0X2dyYXZhdGFyPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc2tldGNoOnR5cGU9Ik1TUGFnZSI+CiAgICAgICAgPGcgaWQ9ImRlZmF1bHRfZ3JhdmF0YXIiIHNrZXRjaDp0eXBlPSJNU0FydGJvYXJkR3JvdXAiPgogICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLTIxMC0rLUltcG9ydGVkLUxheWVycy1Db3B5LUNvcHkiIHNrZXRjaDp0eXBlPSJNU0xheWVyR3JvdXAiPgogICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0yMTAiIGZpbGw9IiNEOEQ4RDgiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiIHg9IjAiIHk9IjAiIHdpZHRoPSIzNiIgaGVpZ2h0PSIzNiI+PC9yZWN0PgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTI3Ljg2OTAzMjEsMjYuODUzNjU2OCBMOCwyNi44NTM2NTY4IEM4LDI1Ljg0OTQ1MTQgOC40NzE4MjUsMjQuMTEwOTQ2NiAxMS41MTg5MDQ1LDIyLjM4ODMxNzYgQzEyLjE1Nzg5NiwyMi4wMjcxMjEzIDE1LjM0Mzk1MTIsMjAuMDk2MTA5OCAxNS42MTU5Njc3LDE5LjYzNzE3MjEgQzE1LjkyNDU4MjgsMTkuMTE3MjA4MSAxNi4wMTA2Mzg5LDE4LjQ3NjE4MzcgMTUuNDIwMTE1OCwxNy41MzI1MDg1IEMxNS4zNzI2MzY2LDE3LjQ1NjEwMTYgMTQuNDM0OTIxNSwxNi4wMDgzMzkxIDE0LjE0NTEwMDMsMTUuMDMwNDI5NyBDMTMuOTQwMzQ2LDE0LjMzODMwMiAxMy45MTc1OTU1LDEzLjU0NTQ1NjEgMTMuOTE3NTk1NSwxMi43MTM0MTQ0IEMxMy45MTc1OTU1LDkuODM2MjQ3MDIgMTUuNzIyMzAxNCw4IDE3Ljk0ODM4NTYsOCBDMjAuMTc0NDY5OSw4IDIxLjk3OTE3NTgsOS44MzYyNDcwMiAyMS45NzkxNzU4LDEyLjcxMzQxNDQgQzIxLjk3OTE3NTgsMTMuMzk5MDkyMiAyMS45NjYzMTY4LDE0LjA1NTk5MzMgMjEuODQ3MTI0MSwxNC42NTM4NTI3IEMyMS42Mzk4OTcsMTUuNjkwMzA3NyAyMC43NzU4NzM2LDE3LjAwNTU5ODQgMjAuNTg4NDI5NSwxNy4zMzA1NzU5IEMyMC41NDM5MTc3LDE3LjQwNzQ3OSAyMC41MDc4MTM3LDE3LjQ2NzUxMyAyMC40ODUwNjMzLDE3LjUwMTI1MTEgQzIwLjA3OTAxNjgsMTguMTA3MDQ4OSAxOS45NjI3OTE2LDE4LjU1MzU4MjkgMjAuMDAwODczOSwxOC45MTUyNzU1IEMyMC4wNDQzOTY1LDE5LjMyODU2NzUgMjAuMzEzOTQwMSwxOS42MTYzMzM4IDIwLjY2NzA2NywxOS44NTQ0ODUzIEMyMS4wMzQ1MzY2LDIwLjEwMjA2MzYgMjQuMDExODgxLDIyLjE0OTY3IDI0LjM3Nzg2NjgsMjIuMzg4MzE3NiBDMjYuODcxNTE2MywyNC4wMTY2NzgzIDI3Ljg2OTAzMjEsMjUuNjA2MzM4NSAyNy44NjkwMzIxLDI2Ljg1MzY1NjggTDI3Ljg2OTAzMjEsMjYuODUzNjU2OCBaIiBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHkiIGZpbGw9IiNGRkZGRkYiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+" class="lazy avatar avatar" title="" style="background-image: none;"></div></div><div data-v-1cbbd4f0="" class="form-box"><div data-v-1cbbd4f0="" class="input-box"><div data-v-1cbbd4f0="" contenteditable="true" spellcheck="false" placeholder="输入评论..." class="rich-input empty"><br data-v-1cbbd4f0=""></div><!----></div><!----></div><input data-v-1cbbd4f0="" type="file" class="hidden"></div><!----><!----></div></div><div data-v-41d33d72="" data-v-3f216172="" st:block="aside" class="entry-public-aside"><div data-v-70a2cd6d="" data-v-fb64097a="" data-v-41d33d72="" class="sidebar-block app-download-sidebar-block shadow"><!----><div data-v-70a2cd6d="" class="block-body"><a data-v-fb64097a="" data-v-70a2cd6d="" class="app-link" href="https://juejin.im/app" target="_blank"><img data-v-fb64097a="" data-v-70a2cd6d="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAEx0lEQVR4Xu2c7XbbMAxD0zffm2cna7NlbuwLkJJjN+hfUiQF8ENS0nxcr9frJX+HQeDjRsjHr/3juT74fOb/Ub6MTomX7C9tdv2NQjCEfCEZQlIhT4sqFZIK+UTA7fFuj+7a7653473rr1bIVk91ndHQVob01hAm+xQvrSc52Sf5o/0QcrlcCHCSE+AkDyELhAhwkhPgJLcJmd1SKvZpk26Lc/W7M2ZtvdSyKoBRwM6Mqvh3AXb1aX+UMCEE7j0hxHiuSYUMuCdQSe/dsqiFpEKaFdJ9e+omBCUcJcCPmyEhhChfyCmDRmboMjRl5oz0r/hTW+Ihjr2VDakbVPPIrThKOPJ76Ja1ByEEYAgx7wXVjLuvCyHGB1CpkH/p9jYz5EdVCLULktNrKcmVU5RzaqJ49/Znv/a6G3A3FELMlhVCviMwsiKlCumSQOudnl4Z+l37tJ72V5Wf4lsn1NJeIa8CTutCSPEzdQK2Kg8hIeQzd6hHk5wykNZ35eS/Kv9TIdXFo9ZVZgD5HnkKIl8j5SFkJJoDbIWQASCONFEe6u5z9TJo6uEjN/nMVjd+iq9q/7SEVDd8B7K7PoQsEOgC2l0fQkLIdg6cfQbsHb/q7+kpS3nMUx0869mK/dEtwW1Ro/en2gshg55OCHCS3xMwhLwrIdSCunLKQJLP9q/aH1IhS2fKjCCAOj2fNj/77ayz/xDyxR4lCJHsrl/TDyEh5BOBURmlHqvJH8mpQlz5rhXiBuf2XLJPM6KyntaQXP18ZkrLouC6hwCyH0IIIZCnQv4BNKRCFECXnLg929Xf8kf5U9kP2VSP8UM+MaxswAXY1e8QMrulbtkPIZTaK08rswgPIWckhE4tZ29ZI/anHmtv/G/hJVUIBaz0XHWoPbvoURK78bnxdu0r/u46IaT4/O5URAhZPM10K2z3CtljBhAorrx7DCZ/s+2v+R/yvSzKoArhrwbMnXkUr3oxDiErSIYQM8Vmt5QQYhIyW31Pwr/90+fszbn2R8wcAtQ5tirxOPa28JDuIS6gXX0FAPIRQgghQ/72hCgAUMapxzqDl6mq7n7cYNxDwV1fPva6G3D1XULdDbv2XQK27CtPJyFk8O91hZCNXzWd0YLdinEr+O0rxAXY1a+27EMce+ktzAVDqRCy6dwrKH5HHkIKb1nOkL7phhDjV7PXKuWlFTKixKkFuMdOtwe7+hQv2SN51b58DyEHrrybgc4xU2kxeybMVjwhRJghzgyotMBvr72vbllUXUp8Myvu7QhRACfSqKeTfM+Whd/LogwgMEhO9iuEVG/Ca8fQ0TPJje/uX/plawKc5CHkf4RSIc1/oesmnHPKkyqk21JmVAiB5M4E156rr86wQxDibm5GgrgxuPohZIGYCogLtKqv+k+FqIg29X4UIZUWdbQZovJ5igqpHAq6N/fqPUIFfi1hQojweYVzbA0hBUAVgN+6QiozQh2S1Yx91Qw6RMs6GyEzKyyEiCXktjBX33pcnJHB3ZbTXS/y8FfNBdjVPz0hLqB7608lpLuZ7j1iRoXOHtrOPegxFmmGhBAfgRDSfEwcPZOGE+LnhLeCACC55+312upMOcTXgLozRrkXuDOjmuE3P7SfrXhDSAFAqrcOIb8BQLPhcIRSNNMAAAAASUVORK5CYII=" class="qr-img"><div data-v-fb64097a="" data-v-70a2cd6d="" class="content-box"><div data-v-fb64097a="" data-v-70a2cd6d="" class="headline">下载掘金客户端</div><div data-v-fb64097a="" data-v-70a2cd6d="" class="desc">一个帮助开发者成长的社区</div></div><!----></a></div></div><div data-v-70a2cd6d="" data-v-1988842d="" data-v-41d33d72="" class="sidebar-block wechat-sidebar-block pure"><div data-v-a0f279e6="" data-v-1988842d="" class="wechat-banner" data-v-70a2cd6d=""><img data-v-a0f279e6="" src="https://b-gold-cdn.xitu.io/v3/static/img/backend.ba44b94.png" class="wechat-img"></div><!----></div><div data-v-1f85cb5f="" data-v-17a8ac96="" data-v-41d33d72="" class="index-book-collect" place="entry" category="5562b419e4b00c57d9b94ae2"><div data-v-1f85cb5f="" class="header"><div data-v-1f85cb5f="" class="title">掘金小册</div><div data-v-1f85cb5f="" class="controllers"><div data-v-1f85cb5f="" class="arrow icon ion-chevron-left"></div><div data-v-1f85cb5f="" class="arrow icon ion-chevron-right"></div></div></div><div data-v-1f85cb5f="" class="slide-book transition--next"><div data-v-133abdc5="" data-v-1f85cb5f="" class="slide-book-list item"><a data-v-133abdc5="" href="/book/5addb2eb6fb9a07abd0d4557" class="item"><div data-v-133abdc5="" class="poster"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-133abdc5="" data-src="https://user-gold-cdn.xitu.io/2018/5/17/1636d772f3d23cf1?imageView2/1/w/104/h/144/q/95/interlace/1" class="lazy thumb poster-img loaded" style="background-image: url(https://user-gold-cdn.xitu.io/2018/5/17/1636d772f3d23cf1?imageView2/1/w/104/h/144/q/95/interlace/1); background-size: cover;"></div></div><div data-v-133abdc5="" class="content-text"><div data-v-133abdc5="" class="title">区块链开发入门：从 0 到 1 构建基于以太坊智能合约的 ICO DApp</div><div data-v-133abdc5="" class="price"><div data-v-133abdc5="" class="new">新人价 ￥34.50</div><div data-v-133abdc5="" class="delete">￥69</div></div></div></a><a data-v-133abdc5="" href="/book/5a0ab8e2f265da43111fbab2" class="item"><div data-v-133abdc5="" class="poster"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-133abdc5="" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd79563b28dd6e?imageView2/1/w/104/h/144/q/95/interlace/1" class="lazy thumb poster-img loaded" style="background-image: url(https://user-gold-cdn.xitu.io/2017/11/20/15fd79563b28dd6e?imageView2/1/w/104/h/144/q/95/interlace/1); background-size: cover;"></div></div><div data-v-133abdc5="" class="content-text"><div data-v-133abdc5="" class="title">如何使用 Canvas 制作出炫酷的网页背景特效</div><div data-v-133abdc5="" class="price"><div data-v-133abdc5="" class="new">新人价 ￥4.95</div><div data-v-133abdc5="" class="delete">￥9.9</div></div></div></a></div></div><div data-v-1f85cb5f="" class="book-newuser"><div data-v-1f85cb5f="" class="newuser-title"><span data-v-1f85cb5f="">新人专享好礼</span></div><div data-v-1f85cb5f="" class="giftbag"><img data-v-1f85cb5f="" src="https://b-gold-cdn.xitu.io/v3/static/img/45.b99ea03.svg"><div data-v-1f85cb5f="" class="content-text"><div data-v-1f85cb5f="" class="title">送你<span data-v-1f85cb5f="" class="highlight">45元</span>买小册</div><div data-v-1f85cb5f="" class="btn-box"><div data-v-1f85cb5f="" class="btn-giftbag">立即领取</div></div></div></div></div></div><!----><div data-v-70a2cd6d="" data-v-f6632f66="" data-v-41d33d72="" class="sidebar-block related-entry-sidebar-block sticky-section shadow" st:block="relatedEntrySidebarBlock" data-v-3f216172=""><div data-v-70a2cd6d="" class="block-title">相关文章</div><div data-v-70a2cd6d="" class="block-body"><div data-v-f6632f66="" data-v-70a2cd6d="" class="entry-list"><a data-v-f6632f66="" href="/post/5bcd19fbe51d457a964d08d7" target="_blank" rel="" st:name="link" class="item" data-v-70a2cd6d=""><div data-v-f6632f66="" class="entry-title">看图轻松理解数据结构与算法系列(红黑树)</div><div data-v-f6632f66="" class="entry-meta-box"><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik00LjIzNCA2LjY5M3Y3LjI0M0gyLjg4MWMtLjQ4NiAwLS44ODEtLjQ5Mi0uODgxLTEuMDk1VjcuODc1YzAtLjYzLjQxMi0xLjE4Mi44OC0xLjE4MmgxLjM1NHptMy42ODgtMy43QzguMDEgMi40MDQgOC40OSAxLjk5IDkuMDE4IDJjLjc1NC4wMTUgMS4yMDQuNjYzIDEuMzYuOTgzLjI4NC41ODUuMjkyIDEuNTQ5LjA5NyAyLjE2Ny0uMTc3LjU2LS41ODYgMS4yOTYtLjU4NiAxLjI5NmgzLjA2NmMuMzI0IDAgLjYyNS4xNjQuODI2LjQ0OS4yMDQuMjkuMjcuNjY4LjE3OCAxLjAxMWwtMS4zODcgNS4xODNjLS4xMjYuNDk5LS41NDQuODQ3LTEuMDE2Ljg0N0g1LjUzVjYuNjkzYzEuMzg1LS4zMDkgMi4yMzYtMi42MzIgMi4zOTItMy43eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">28</span></div><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik0yIDR2OC4wMzhoNC40NDRMMTEuMTExIDE1di0yLjk2MkgxNFY0eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">2</span></div></div></a><a data-v-f6632f66="" href="/post/5bc7067c6fb9a05d1117b2ef" target="_blank" rel="" st:name="link" class="item" data-v-70a2cd6d=""><div data-v-f6632f66="" class="entry-title">掘金直播 第十一期小程序专场  打码指南：由猫眼线下扫码1分购谈起</div><div data-v-f6632f66="" class="entry-meta-box"><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik00LjIzNCA2LjY5M3Y3LjI0M0gyLjg4MWMtLjQ4NiAwLS44ODEtLjQ5Mi0uODgxLTEuMDk1VjcuODc1YzAtLjYzLjQxMi0xLjE4Mi44OC0xLjE4MmgxLjM1NHptMy42ODgtMy43QzguMDEgMi40MDQgOC40OSAxLjk5IDkuMDE4IDJjLjc1NC4wMTUgMS4yMDQuNjYzIDEuMzYuOTgzLjI4NC41ODUuMjkyIDEuNTQ5LjA5NyAyLjE2Ny0uMTc3LjU2LS41ODYgMS4yOTYtLjU4NiAxLjI5NmgzLjA2NmMuMzI0IDAgLjYyNS4xNjQuODI2LjQ0OS4yMDQuMjkuMjcuNjY4LjE3OCAxLjAxMWwtMS4zODcgNS4xODNjLS4xMjYuNDk5LS41NDQuODQ3LTEuMDE2Ljg0N0g1LjUzVjYuNjkzYzEuMzg1LS4zMDkgMi4yMzYtMi42MzIgMi4zOTItMy43eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">5</span></div><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik0yIDR2OC4wMzhoNC40NDRMMTEuMTExIDE1di0yLjk2MkgxNFY0eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">0</span></div></div></a><a data-v-f6632f66="" href="/post/5bcd157b6fb9a05d0b146ef7" target="_blank" rel="" st:name="link" class="item" data-v-70a2cd6d=""><div data-v-f6632f66="" class="entry-title">利用责任链模式设计一个拦截器</div><div data-v-f6632f66="" class="entry-meta-box"><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik00LjIzNCA2LjY5M3Y3LjI0M0gyLjg4MWMtLjQ4NiAwLS44ODEtLjQ5Mi0uODgxLTEuMDk1VjcuODc1YzAtLjYzLjQxMi0xLjE4Mi44OC0xLjE4MmgxLjM1NHptMy42ODgtMy43QzguMDEgMi40MDQgOC40OSAxLjk5IDkuMDE4IDJjLjc1NC4wMTUgMS4yMDQuNjYzIDEuMzYuOTgzLjI4NC41ODUuMjkyIDEuNTQ5LjA5NyAyLjE2Ny0uMTc3LjU2LS41ODYgMS4yOTYtLjU4NiAxLjI5NmgzLjA2NmMuMzI0IDAgLjYyNS4xNjQuODI2LjQ0OS4yMDQuMjkuMjcuNjY4LjE3OCAxLjAxMWwtMS4zODcgNS4xODNjLS4xMjYuNDk5LS41NDQuODQ3LTEuMDE2Ljg0N0g1LjUzVjYuNjkzYzEuMzg1LS4zMDkgMi4yMzYtMi42MzIgMi4zOTItMy43eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">19</span></div><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik0yIDR2OC4wMzhoNC40NDRMMTEuMTExIDE1di0yLjk2MkgxNFY0eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">2</span></div></div></a><a data-v-f6632f66="" href="/post/5bcd2022f265da0abe273330" target="_blank" rel="" st:name="link" class="item" data-v-70a2cd6d=""><div data-v-f6632f66="" class="entry-title">Go语言性能优化- For Range 性能研究</div><div data-v-f6632f66="" class="entry-meta-box"><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik00LjIzNCA2LjY5M3Y3LjI0M0gyLjg4MWMtLjQ4NiAwLS44ODEtLjQ5Mi0uODgxLTEuMDk1VjcuODc1YzAtLjYzLjQxMi0xLjE4Mi44OC0xLjE4MmgxLjM1NHptMy42ODgtMy43QzguMDEgMi40MDQgOC40OSAxLjk5IDkuMDE4IDJjLjc1NC4wMTUgMS4yMDQuNjYzIDEuMzYuOTgzLjI4NC41ODUuMjkyIDEuNTQ5LjA5NyAyLjE2Ny0uMTc3LjU2LS41ODYgMS4yOTYtLjU4NiAxLjI5NmgzLjA2NmMuMzI0IDAgLjYyNS4xNjQuODI2LjQ0OS4yMDQuMjkuMjcuNjY4LjE3OCAxLjAxMWwtMS4zODcgNS4xODNjLS4xMjYuNDk5LS41NDQuODQ3LTEuMDE2Ljg0N0g1LjUzVjYuNjkzYzEuMzg1LS4zMDkgMi4yMzYtMi42MzIgMi4zOTItMy43eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">8</span></div><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik0yIDR2OC4wMzhoNC40NDRMMTEuMTExIDE1di0yLjk2MkgxNFY0eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">0</span></div></div></a></div></div></div></div></div><div data-v-2febaf4d="" data-v-41d33d72="" class="article-suspended-panel article-suspended-panel" data-v-3f216172=""><div data-v-2febaf4d="" badge="23" class="like-btn panel-btn like-adjust with-badge"></div><div data-v-2febaf4d="" badge="0" class="comment-btn panel-btn comment-adjust"></div><div data-v-2febaf4d="" class="collect-btn panel-btn"><!----></div><div data-v-2febaf4d="" class="share-title">分享</div><div data-v-2febaf4d="" class="weibo-btn share-btn panel-btn"></div><div data-v-2febaf4d="" class="qq-btn share-btn panel-btn"></div><div data-v-2febaf4d="" class="wechat-btn share-btn panel-btn"><img data-v-2febaf4d="" src="" class="wechat-qr-code-img shadow" style="display: none;"></div></div><div data-v-f0e3c22e="" data-v-41d33d72="" class="image-viewer-box" data-v-3f216172=""><!----></div><div data-v-00a4671b="" data-v-41d33d72="" st:block="mobileBottomBar" class="mobile-bottom-bar" data-v-3f216172=""><div data-v-00a4671b="" class="bar-container"><a data-v-00a4671b="" href="https://juejin.im/about" class="left"><img data-v-00a4671b="" src="https://b-gold-cdn.xitu.io/images/logo-bold.svg"><span data-v-00a4671b="">一个帮助开发者成长的社区</span></a><a data-v-00a4671b="" st:name="openInAppBtn" class="button">打开应用<div data-v-00a4671b="" class="pop-up" style="display: none;"><a data-v-00a4671b="" class="pop-up-content"></a></div></a></div></div></main></div><div data-v-19078e6d="" data-v-6ede48a3="" class="recommend-box"><div data-v-19078e6d="" class="extension"><div data-v-19078e6d="" data-growing-container="true" data-growing-title="掘金插件" class="link"><div data-v-19078e6d="" class="title">掘金浏览器插件 - 下载插件，送你<span data-v-19078e6d="" class="price">45元</span>买小册</div></div><div data-v-19078e6d="" class="ion-close"></div></div><!----></div></div>
      
      <script type="text/javascript" src="https://b-gold-cdn.xitu.io/v3/static/js/manifest.20254fa563d3539b68bf.js"></script><script type="text/javascript" src="https://b-gold-cdn.xitu.io/v3/static/js/vendor.e6fd81aa1499049a5bee.js"></script><script type="text/javascript" src="https://b-gold-cdn.xitu.io/v3/static/js/app.a99a1e8180beec940a3f.js"></script>
    </body></html>