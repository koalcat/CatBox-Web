<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover"><meta name="google-site-verification" content="cCHsgG9ktuCTgWgYfqCJql8AeR4gAne4DTZqztPoirE"><meta name="apple-itunes-app" content="app-id=987739104"><meta name="baidu-site-verification" content="qiK2a1kcFc"><meta name="360-site-verification" content="4c3c7d57d59f0e1a308462fbc7fd7e51"><meta name="sogou_site_verification" content="c49WUDZczQ"><meta data-vue-meta="true" data-vmid="keywords" name="keywords" content="Java"><meta data-vue-meta="true" data-vmid="description" name="description" content="自我表扬：《Dubbo 实现原理与源码解析 —— 精品合集》 表扬自己：《D数据库实体设计合集》 摘要: 原创出处 http://www.iocoder.cn/RocketMQ/message-pull-and-consume-second/ 「芋道"><title data-vue-meta="true">分布式消息队列 RocketMQ 源码分析 —— Message 拉取与消费（下） - 后端 - 掘金</title><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/js/manifest.20254fa563d3539b68bf.js" as="script"><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/js/vendor.e6fd81aa1499049a5bee.js" as="script"><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/js/app.a99a1e8180beec940a3f.js" as="script"><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/css/app.37151bbb8a40894c7953daf9b02b2ff7.css" as="style"><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/js/3.f84ea6333e04793cc1e2.js" as="script"><link rel="apple-touch-icon" sizes="180x180" href="https://b-gold-cdn.xitu.io/favicons/v2/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon-16x16.png"><link rel="manifest" href="https://b-gold-cdn.xitu.io/favicons/v2/manifest.json"><link rel="mask-icon" href="https://b-gold-cdn.xitu.io/favicons/v2/safari-pinned-tab.svg" color="#5bbad5"><link rel="shortcut icon" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon.ico"><meta name="msapplication-config" content="https://b-gold-cdn.xitu.io/favicons/v2/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="search" title="掘金" href="https://b-gold-cdn.xitu.io/conf/search.xml" type="application/opensearchdescription+xml"><link rel="stylesheet" href="https://b-gold-cdn.xitu.io/ionicons/2.0.1/css/ionicons.min.css"><link rel="stylesheet" href="https://b-gold-cdn.xitu.io/asset/fw-icon/1.0.9/iconfont.css"><link href="https://b-gold-cdn.xitu.io/v3/static/css/app.37151bbb8a40894c7953daf9b02b2ff7.css" rel="stylesheet"><script async="" src="https://hm.baidu.com/hm.js?93bbd335a208870aa1f296bcd6842e5e"></script><script async="" src="//www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://assets.growingio.com/vds.js"></script><script type="text/javascript" charset="utf-8" async="" src="https://b-gold-cdn.xitu.io/v3/static/js/3.f84ea6333e04793cc1e2.js"></script></head><body><div id="juejin" data-v-6ede48a3=""><div class="global-component-box" data-v-6ede48a3=""><!----><div data-v-2840e9c3="" data-v-6ede48a3="" class="alert-list alert-list"></div><div data-v-6ddb54c6="" data-v-6ede48a3="" class="suspension-panel suspension-panel"><button data-v-6ddb54c6="" title="回到顶部" class="btn to-top-btn" style="display: none;"><i data-v-6ddb54c6="" class="ion-android-arrow-dropup"></i></button><button data-v-6ddb54c6="" title="建议反馈" class="btn meiqia-btn" style=""><i data-v-6ddb54c6="" class="ion-chatbubble-working"></i></button></div><!----><!----><div class="emoji-barrage" data-v-475389e2="" data-v-6ede48a3=""><!----></div><div class="book-new-user-award-popup" style="display: none;" data-v-7c95f01f="" data-v-6ede48a3=""><div class="content-box" style="display:;" data-v-7c95f01f=""><div class="close ion-close-round" data-v-7c95f01f=""></div><div class="header" data-v-7c95f01f=""><div class="icon" data-v-7c95f01f=""><img src="https://b-gold-cdn.xitu.io/v3/static/img/icon.a87e5ae.svg" data-v-7c95f01f=""></div><div class="txt" data-v-7c95f01f="">新人专享好礼</div></div><div class="desc" data-v-7c95f01f="">凡未购买过小册的用户，均可领取三张 5 折新人专享券，购买小册时自动使用专享券，最高可节省 45 元。</div><div class="tickets" data-v-7c95f01f=""><div class="ticket" data-v-7c95f01f=""><div class="ticket__inner" data-v-7c95f01f=""><div class="enjoy" data-v-7c95f01f=""><span class="new-title" data-v-7c95f01f="">小册新人 5 折券</span></div><div class="sale" data-v-7c95f01f="">最高可省 15 元</div></div></div><div class="ticket" data-v-7c95f01f=""><div class="ticket__inner" data-v-7c95f01f=""><div class="enjoy" data-v-7c95f01f=""><span class="new-title" data-v-7c95f01f="">小册新人 5 折券</span></div><div class="sale" data-v-7c95f01f="">最高可省 15 元</div></div></div><div class="ticket" data-v-7c95f01f=""><div class="ticket__inner" data-v-7c95f01f=""><div class="enjoy" data-v-7c95f01f=""><span class="new-title" data-v-7c95f01f="">小册新人 5 折券</span></div><div class="sale" data-v-7c95f01f="">最高可省 15 元</div></div></div></div><div class="remark" data-v-7c95f01f="">注：专享券的使用期限在领券的七天内。</div><div class="submit-btn" data-v-7c95f01f="">一键领取</div></div><div class="model success" style="display: none;" data-v-7c95f01f=""><div class="heading" data-v-7c95f01f="">领取成功</div><div class="content-text" data-v-7c95f01f="">购买小册时自动使用专享券</div><div class="btn-success-footer" data-v-7c95f01f=""><div class="btn-ok" data-v-7c95f01f="">知道了</div><div class="btn-ok btn-link" data-v-7c95f01f="">前往小册首页</div></div></div><div class="model fail" style="display: none;" data-v-7c95f01f=""><div class="heading" data-v-7c95f01f="">领取失败</div><div class="content-text" data-v-7c95f01f="">本活动仅适用于小册新用户</div><div class="btn-ok" data-v-7c95f01f="">知道了</div></div></div><!----></div><!----><div data-v-3f216172="" data-v-41d33d72="" data-v-6ede48a3="" class="view-container"><div data-v-3f216172="" class="main-header-box"><header data-v-5ce25e66="" data-v-3f216172="" class="main-header main-header unauthorized visible"><div data-v-5ce25e66="" class="container"><a data-v-5ce25e66="" href="/" class="logo"><img data-v-5ce25e66="" src="https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg" alt="掘金" class="logo-img"></a><nav data-v-5ce25e66="" role="navigation" class="main-nav"><ul data-v-5ce25e66="" class="nav-list"><li data-v-5ce25e66="" class="main-nav-list"><div data-v-5ce25e66="" class="phone-show-menu"><span data-v-5ce25e66="">首页</span><div data-v-5ce25e66="" class="icon ion-arrow-down-b"></div></div><ul data-v-5ce25e66="" class="phone-hide"><li data-v-5ce25e66="" class="nav-item link-item route-active"><a data-v-5ce25e66="" href="/">首页</a></li><li data-v-5ce25e66="" class="nav-item link-item pin"><a data-v-5ce25e66="" href="/pins">沸点</a><!----></li><li data-v-5ce25e66="" class="nav-item link-item book"><a data-v-5ce25e66="" href="/books">小册</a></li><li data-v-5ce25e66="" class="nav-item link-item"><a data-v-5ce25e66="" href="/repos">开源库</a></li><li data-v-5ce25e66="" class="nav-item link-item"><a data-v-5ce25e66="" href="/events/all">活动</a></li><li data-v-5ce25e66="" class="nav-item link-item conf"><a data-v-5ce25e66="" st:name="confGif" title="掘金开发者大会 · 微信小程序专场" target="_blank" href="https://conf.juejin.im/2018/mini-programs"><img data-v-5ce25e66="" src="https://b-gold-cdn.xitu.io/v3/static/img/conf.78960f5.gif" alt="掘金开发者大会 · 微信小程序专场" class="conf-icon"></a></li></ul></li><li data-v-5ce25e66="" class="nav-item search"><form data-v-5ce25e66="" role="search" class="search-form"><input data-v-5ce25e66="" maxlength="32" placeholder="搜索掘金" class="search-input"><img data-v-5ce25e66="" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjJweCIgaGVpZ2h0PSIyMnB4IiB2aWV3Qm94PSIwIDAgMjIgMjIiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogc2tldGNodG9vbCA0MS4yICgzNTM5NykgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Qjk3RUIxMEEtOEYzNC00QUI1LUFCQUYtNDFEOTMzNzQxRUQwPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBza2V0Y2h0b29sLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSLpppbpobUiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSLlr7zoiKrmoI/mkJzntKLmoYYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC05OTAuMDAwMDAwLCAtMTkuMDAwMDAwKSIgZmlsbD0iI0MzQ0NENSI+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTkwLjAwMDAwMCwgMTkuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuOTg2MTI2LDE0LjQwMDMzOTUgTDE2LjI5Mjg5MzIsMTcuNzA3MTA2OCBDMTYuNjgzNDE3NSwxOC4wOTc2MzExIDE3LjMxNjU4MjUsMTguMDk3NjMxMSAxNy43MDcxMDY4LDE3LjcwNzEwNjggQzE4LjA5NzYzMTEsMTcuMzE2NTgyNSAxOC4wOTc2MzExLDE2LjY4MzQxNzUgMTcuNzA3MTA2OCwxNi4yOTI4OTMyIEwxNC40MDAzMzk1LDEyLjk4NjEyNiBDMTUuOTYwMzg4MSwxMC43NTczMjk4IDE1Ljc0NTI0MDIsNy42NjQwMTk4MyAxMy43NTQ4OTU5LDUuNjczNjc1NTQgQzExLjUyMzMyODUsMy40NDIxMDgxNSA3LjkwNTI0MjkyLDMuNDQyMTA4MTUgNS42NzM2NzU1NCw1LjY3MzY3NTU0IEMzLjQ0MjEwODE1LDcuOTA1MjQyOTIgMy40NDIxMDgxNSwxMS41MjMzMjg1IDUuNjczNjc1NTQsMTMuNzU0ODk1OSBDNy42NjQwMTk4MywxNS43NDUyNDAyIDEwLjc1NzMyOTgsMTUuOTYwMzg4MSAxMi45ODYxMjYsMTQuNDAwMzM5NSBaIE03LjA4Nzg4OTEsMTIuMzQwNjgyMyBDNS42MzczNzAzLDEwLjg5MDE2MzUgNS42MzczNzAzLDguNTM4NDA3OSA3LjA4Nzg4OTEsNy4wODc4ODkxIEM4LjUzODQwNzksNS42MzczNzAzIDEwLjg5MDE2MzUsNS42MzczNzAzIDEyLjM0MDY4MjMsNy4wODc4ODkxIEMxMy43OTEyMDExLDguNTM4NDA3OSAxMy43OTEyMDExLDEwLjg5MDE2MzUgMTIuMzQwNjgyMywxMi4zNDA2ODIzIEMxMC44OTAxNjM1LDEzLjc5MTIwMTEgOC41Mzg0MDc5LDEzLjc5MTIwMTEgNy4wODc4ODkxLDEyLjM0MDY4MjMgWiIgaWQ9IkNvbWJpbmVkLVNoYXBlIj48L3BhdGg+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==" alt="搜索" class="search-icon"></form></li><!----><!----><!----><li data-v-5ce25e66="" class="nav-item submit"><img data-v-5ce25e66="" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjJweCIgaGVpZ2h0PSIyMnB4IiB2aWV3Qm94PSIwIDAgMjIgMjIiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogc2tldGNodG9vbCA0MiAoMzY3ODEpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPjA1Q0I0NzU5LUIyRkQtNDcxOC04RTBDLTg0OEVCNzQ2RDAyMzwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggc2tldGNodG9vbC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8cmVjdCBpZD0icGF0aC0xIiB4PSIyMzgiIHk9IjEyOCIgd2lkdGg9IjcwMCIgaGVpZ2h0PSI1MCIgcng9IjIiPjwvcmVjdD4KICAgICAgICA8ZmlsdGVyIHg9Ii01MCUiIHk9Ii01MCUiIHdpZHRoPSIyMDAlIiBoZWlnaHQ9IjIwMCUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci0yIj4KICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSIwIiBkeT0iMSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd09mZnNldE91dGVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMSIgaW49InNoYWRvd09mZnNldE91dGVyMSIgcmVzdWx0PSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC4wNTAyNzE3MzkxIDAiIHR5cGU9Im1hdHJpeCIgaW49InNoYWRvd0JsdXJPdXRlcjEiPjwvZmVDb2xvck1hdHJpeD4KICAgICAgICA8L2ZpbHRlcj4KICAgICAgICA8cmVjdCBpZD0icGF0aC0zIiB4PSI0IiB5PSI0IiB3aWR0aD0iMTMiIGhlaWdodD0iMTQiIHJ4PSIyIj48L3JlY3Q+CiAgICAgICAgPG1hc2sgaWQ9Im1hc2stNCIgbWFza0NvbnRlbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hc2tVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHg9IjAiIHk9IjAiIHdpZHRoPSIxMyIgaGVpZ2h0PSIxNCIgZmlsbD0id2hpdGUiPgogICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9IiNwYXRoLTMiPjwvdXNlPgogICAgICAgIDwvbWFzaz4KICAgIDwvZGVmcz4KICAgIDxnIGlkPSLpppbpobUiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSLpppbpobUyX0NvX+aZrumAmueUqOaItyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMwNS4wMDAwMDAsIC0xNDIuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSJDb21iaW5lZC1TaGFwZSI+CiAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMikiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgPHVzZSBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cC0zMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzA1LjAwMDAwMCwgMTQyLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0zIiB4PSIwIiB5PSIwIiB3aWR0aD0iMjIiIGhlaWdodD0iMjIiPjwvcmVjdD4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik05Ljg5NTY2MjY1LDkuMzQ2Mjc4MzIgTDYuNjY3NTA3MzEsOS4zNDYyNzgzMiBDNi4zNzA1MDcxNyw5LjM0NjI3ODMyIDYuMTI5NDQ5ODQsOS4xMDI3MDQ4MiA2LjEyOTQ0OTg0LDguODAyNTc4MzYgQzYuMTI5NDQ5ODQsOC41MDI0NzMxNyA2LjM3MDUwNzE3LDguMjU4ODk5NjggNi42Njc1MDczMSw4LjI1ODg5OTY4IEw5Ljg5NTY4MzcxLDguMjU4ODk5NjggQzEwLjE5MjYyMDcsOC4yNTg4OTk2OCAxMC40MzM2NTcsOC41MDI0NzMxNyAxMC40MzM2NTcsOC44MDI1NzgzNiBDMTAuNDMzNjM1OSw5LjEwMjcwNDgyIDEwLjE5MjU5OTYsOS4zNDYyNzgzMiA5Ljg5NTY2MjY1LDkuMzQ2Mjc4MzIgTTEzLjExMzIzNzEsMTIuNjA4NDE0MiBMNi42NjY2OTgyLDEyLjYwODQxNDIgQzYuMzcwMTQ0NjcsMTIuNjA4NDE0MiA2LjEyOTQ0OTg0LDEyLjM2NTQwNTcgNi4xMjk0NDk4NCwxMi4wNjQ3NTY4IEM2LjEyOTQ0OTg0LDExLjc2NDAyMjkgNi4zNzAxNDQ2NywxMS41MjEwMzU2IDYuNjY2Njk4MiwxMS41MjEwMzU2IEwxMy4xMTMyMzcxLDExLjUyMTAzNTYgQzEzLjQxMDI3NDEsMTEuNTIxMDM1NiAxMy42NTA0ODU0LDExLjc2NDAyMjkgMTMuNjUwNDg1NCwxMi4wNjQ3NTY4IEMxMy42NTA0ODU0LDEyLjM2NTM4NDQgMTMuNDEwMjc0MSwxMi42MDg0MTQyIDEzLjExMzIzNzEsMTIuNjA4NDE0MiIgaWQ9Imljb25mb250LWJpYW5qaSIgZmlsbD0iIzAwN0ZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgPHVzZSBpZD0iUmVjdGFuZ2xlIiBzdHJva2U9IiMwMDdGRkYiIG1hc2s9InVybCgjbWFzay00KSIgc3Ryb2tlLXdpZHRoPSIyIiB4bGluazpocmVmPSIjcGF0aC0zIj48L3VzZT4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+" class="icon"><span data-v-5ce25e66="">写文章</span><!----></li><li data-v-5ce25e66="" class="nav-item auth"><span data-v-5ce25e66="" class="login">登录</span><span data-v-5ce25e66="" class="register">注册</span></li></ul></nav></div></header></div><main data-v-3f216172="" class="container main-container"><div data-v-41d33d72="" data-v-3f216172="" class="view entry-public-view"><div data-v-41d33d72="" data-v-3f216172="" class="entry-public-main shadow"><!----><!----><article data-v-41d33d72="" itemscope="itemscope" itemtype="http://schema.org/Article" class="entry-content-box" data-v-3f216172=""><meta itemprop="url" content="https://juejin.im/entry/5bcba5826fb9a05d353cb019"><meta itemprop="headline" content="分布式消息队列 RocketMQ 源码分析 —— Message 拉取与消费（下）"><meta itemprop="keywords" content="Java"><meta itemprop="datePublished" content="2018-10-20T22:00:34.634Z"><meta itemprop="image" content="https://b-gold-cdn.xitu.io/icon/icon-128.png"><div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java公众号_芋道源码_每日更新"><meta itemprop="url" content="https://juejin.im/user/5904c637b123db3ee479d923"></div><div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"><div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://b-gold-cdn.xitu.io/icon/icon-white-180.png"><meta itemprop="width" content="180"><meta itemprop="height" content="180"></div></div><h1 data-v-41d33d72="">分布式消息队列 RocketMQ 源码分析 —— Message 拉取与消费（下）</h1><div data-v-41d33d72="" class="entry-public-info"><div data-v-41d33d72="" class="text-muted info-item">阅读 1781</div><div data-v-41d33d72="" class="text-muted info-item">收藏 22</div><div data-v-41d33d72="" class="text-muted info-item">2018-10-21</div></div><div data-v-41d33d72="" class="originalUrl">原文链接：<a data-v-41d33d72="" st:name="originLink" href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%3Fjuejin%262018-10-21" rel="nofollow noopener noreferrer" target="_blank">www.iocoder.cn</a></div><a data-v-41d33d72="" class="banner" href="https://cloud.tencent.com/act/special/amd?fromSource=gwzcw.1351356.1351356.1351356" rel="nofollow noopener noreferrer" target="_blank"><span data-v-41d33d72="" class="text">AMD CPU云服务器全国首推</span><span data-v-41d33d72="" class="link">cloud.tencent.com</span></a><div data-v-41d33d72="" itemprop="articleBody" class="entry-content article-content"> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FDubbo%2Fgood-collection%2F%3Ftitle" target="_blank" rel="nofollow noopener noreferrer">自我表扬：《Dubbo 实现原理与源码解析 —— 精品合集》</a> <br> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FEntity%2Fgood-collection%2F%3Ftitle" target="_blank" rel="nofollow noopener noreferrer">表扬自己：《D数据库实体设计合集》</a>
    <p>摘要: 原创出处 <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">www.iocoder.cn/RocketMQ/me…</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p>
    <p><strong>本文主要基于 RocketMQ 4.0.x 正式版</strong> </p>
    <ul>
        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">1、概述</a></li>
        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">2、Consumer</a></li>
        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">3、PushConsumer 一览</a></li>
        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">4、PushConsumer 订阅</a>
            <ul>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">DefaultMQPushConsumerImpl#subscribe(…)</a>
                    <ul>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">FilterAPI.buildSubscriptionData(…)</a></li>
                    </ul>
                </li>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">DefaultMQPushConsumer#registerMessageListener(…)</a></li>
            </ul>
        </li>
        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">5、PushConsumer 消息队列分配</a>
            <ul>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">RebalanceService</a></li>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">MQClientInstance#doRebalance(…)</a></li>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">DefaultMQPushConsumerImpl#doRebalance(…)</a></li>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">RebalanceImpl#doRebalance(…)</a>
                    <ul>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">RebalanceImpl#rebalanceByTopic(…)</a></li>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">RebalanceImpl#removeUnnecessaryMessageQueue(…)</a>
                            <ul>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">RebalancePushImpl#removeUnnecessaryMessageQueue(…)</a></li>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">[PullConsumer] RebalancePullImpl#removeUnnecessaryMessageQueue(…)</a></li>
                            </ul>
                        </li>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">RebalancePushImpl#dispatchPullRequest(…)</a>
                            <ul>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">DefaultMQPushConsumerImpl#executePullRequestImmediately(…)</a></li>
                            </ul>
                        </li>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">AllocateMessageQueueStrategy</a>
                            <ul>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">AllocateMessageQueueAveragely</a></li>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">AllocateMessageQueueByMachineRoom</a></li>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">AllocateMessageQueueAveragelyByCircle</a></li>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">AllocateMessageQueueByConfig</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">5、PushConsumer 消费进度读取</a>
            <ul>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">RebalancePushImpl#computePullFromWhere(…)</a></li>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">[PullConsumer] RebalancePullImpl#computePullFromWhere(…)</a></li>
            </ul>
        </li>
        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">6、PushConsumer 拉取消息</a>
            <ul>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">PullMessageService</a></li>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">DefaultMQPushConsumerImpl#pullMessage(…)</a>
                    <ul>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">PullAPIWrapper#pullKernelImpl(…)</a>
                            <ul>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">PullAPIWrapper#recalculatePullFromWhichNode(…)</a></li>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">MQClientInstance#findBrokerAddressInSubscribe(…)</a></li>
                            </ul>
                        </li>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">PullAPIWrapper#processPullResult(…)</a></li>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">ProcessQueue#putMessage(…)</a></li>
                    </ul>
                </li>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">总结</a></li>
            </ul>
        </li>
        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">6、PushConsumer 消费消息</a>
            <ul>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">ConsumeMessageConcurrentlyService 提交消费请求</a>
                    <ul>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">ConsumeMessageConcurrentlyService#submitConsumeRequest(…)</a></li>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">ConsumeMessageConcurrentlyService#submitConsumeRequestLater</a></li>
                    </ul>
                </li>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">ConsumeRequest</a></li>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">ConsumeMessageConcurrentlyService#processConsumeResult(…)</a>
                    <ul>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">ProcessQueue#removeMessage(…)</a></li>
                    </ul>
                </li>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">ConsumeMessageConcurrentlyService#cleanExpireMsg(…)</a>
                    <ul>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">ProcessQueue#cleanExpiredMsg(…)</a></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">7、PushConsumer 发回消费失败消息</a>
            <ul>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">DefaultMQPushConsumerImpl#sendMessageBack(…)</a>
                    <ul>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">MQClientAPIImpl#consumerSendMessageBack(…)</a></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">8、Consumer 消费进度</a>
            <ul>
                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">OffsetStore</a>
                    <ul>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">OffsetStore#load(…)</a>
                            <ul>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">LocalFileOffsetStore#load(…)</a>
                                    <ul>
                                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">OffsetSerializeWrapper</a></li>
                                    </ul>
                                </li>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">RemoteBrokerOffsetStore#load(…)</a></li>
                            </ul>
                        </li>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">OffsetStore#readOffset(…)</a>
                            <ul>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">LocalFileOffsetStore#readOffset(…)</a></li>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">RemoteBrokerOffsetStore#readOffset(…)</a></li>
                            </ul>
                        </li>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">OffsetStore#updateOffset(…)</a></li>
                        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">OffsetStore#persistAll(…)</a>
                            <ul>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">LocalFileOffsetStore#persistAll(…)</a></li>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">RemoteBrokerOffsetStore#persistAll(…)</a></li>
                                <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">MQClientInstance#persistAllConsumerOffset(…)</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-second%2F" target="_blank" rel="nofollow noopener noreferrer">9、结尾</a></li>
    </ul>
    <hr>
    <p><img alt="" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/10/18/166840b9b5db2e09?imageView2/0/w/1280/h/960/ignore-error/1" data-width="1280" data-height="536" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;536&quot;&gt;&lt;/svg&gt;"></p>
    <blockquote>
        <p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利： </p>
        <ol>
            <li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表 </li>
            <li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong> </li>
            <li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。 </li>
            <li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。 </li>
            <li><strong>认真的</strong>源码交流微信群。</li>
        </ol>
    </blockquote>
    <hr>
    <h1 id="1、概述" data-id="heading-0"><a href="#1、概述" title="1、概述"></a>1、概述</h1>
    <p>本文接：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-first%2F" target="_blank" rel="nofollow noopener noreferrer">《RocketMQ 源码分析 —— Message 拉取与消费（上）》</a>。</p>
    <p>主要解析 <code>Consumer</code> 在 <strong>消费</strong> 逻辑涉及到的源码。</p>
    <h1 id="2、Consumer" data-id="heading-1"><a href="#2、Consumer" title="2、Consumer"></a>2、Consumer</h1>
    <p>MQ 提供了两类消费者：</p>
    <ul>
        <li>PushConsumer：
            <ul>
                <li>在大多数场景下使用。</li>
                <li>名字虽然是 <code>Push</code> 开头，实际在实现时，使用 <code>Pull</code> 方式实现。通过 <code>Pull</code> <strong>不断不断不断</strong>轮询 <code>Broker</code> 获取消息。当不存在新消息时，<code>Broker</code> 会<strong>挂起请求</strong>，直到有新消息产生，取消挂起，返回新消息。这样，基本和 <code>Broker</code> 主动 <code>Push</code>                    做到<strong>接近</strong>的实时性（当然，还是有相应的实时性损失）。原理类似 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.ibm.com%2Fdeveloperworks%2Fcn%2Fweb%2Fwa-lo-comet%2F" target="_blank" rel="nofollow noopener noreferrer">长轮询( <code>Long-Polling</code> )</a>。</li>
            </ul>
        </li>
        <li>PullConsumer</li>
    </ul>
    <p>本文主要讲解<code>PushConsumer</code>，部分讲解<code>PullConsumer</code>，跳过<code>顺序消费</code>。<br><strong>本文主要讲解<code>PushConsumer</code>，部分讲解<code>PullConsumer</code>，跳过<code>顺序消费</code>。</strong><br><strong>本文主要讲解<code>PushConsumer</code>，部分讲解<code>PullConsumer</code>，跳过<code>顺序消费</code>。</strong>        </p>
    <h1 id="3、PushConsumer-一览" data-id="heading-2"><a href="#3、PushConsumer-一览" title="3、PushConsumer 一览"></a>3、PushConsumer 一览</h1>
    <p>先看一张 <code>PushConsumer</code> 包含的组件以及组件之间的交互图：</p>
    <p><img alt="PushConsumer手绘图.png" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/10/21/166937eae560d8ac?imageView2/0/w/1280/h/960/ignore-error/1" data-width="1280" data-height="1151" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;1151&quot;&gt;&lt;/svg&gt;"></p>
    <ul>
        <li><code>RebalanceService</code>：均衡消息队列服务，负责分配当前 <code>Consumer</code> 可消费的消息队列( <code>MessageQueue</code> )。当有新的 <code>Consumer</code> 的加入或移除，都会重新分配消息队列。</li>
        <li><code>PullMessageService</code>：拉取消息服务，<strong>不断不断不断</strong>从 <code>Broker</code> 拉取消息，并提交消费任务到 <code>ConsumeMessageService</code>。</li>
        <li><code>ConsumeMessageService</code>：消费消息服务，<strong>不断不断不断</strong>消费消息，并处理消费结果。</li>
        <li><code>RemoteBrokerOffsetStore</code>：<code>Consumer</code> 消费进度管理，负责从 <code>Broker</code> 获取消费进度，同步消费进度到 <code>Broker</code>。</li>
        <li><code>ProcessQueue</code> ：消息处理队列。</li>
        <li><code>MQClientInstance</code> ：封装对 <code>Namesrv</code>，<code>Broker</code> 的 API调用，提供给 <code>Producer</code>、<code>Consumer</code> 使用。</li>
    </ul>
    <h1 id="4、PushConsumer-订阅" data-id="heading-3"><a href="#4、PushConsumer-订阅" title="4、PushConsumer 订阅"></a>4、PushConsumer 订阅</h1>
    <h2 id="DefaultMQPushConsumerImpl-subscribe-…" data-id="heading-4"><a href="#DefaultMQPushConsumerImpl-subscribe-…" title="DefaultMQPushConsumerImpl#subscribe(…)"></a>DefaultMQPushConsumerImpl#subscribe(…)</h2>
    <pre><code> 1: public void subscribe(String topic, String subExpression) throws MQClientException {
 2:     try {
 3:         // 创建订阅数据
 4:         SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(), //
 5:             topic, subExpression);
 6:         this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
 7:         // 通过心跳同步Consumer信息到Broker
 8:         if (this.mQClientFactory != null) {
 9:             this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
10:         }
11:     } catch (Exception e) {
12:         throw new MQClientException("subscription exception", e);
13:     }
14: }
</code></pre>
    <ul>
        <li>说明 ：订阅 <code>Topic</code> 。</li>
        <li>第 3 至 6 行 ：创建订阅数据。详细解析见：<a href="#filterapibuildsubscriptiondata">FilterAPI.buildSubscriptionData(…)</a>。</li>
        <li>第 7 至 10 行 ：通过心跳同步 <code>Consumer</code> 信息到 <code>Broker</code>。</li>
    </ul>
    <h3 id="FilterAPI-buildSubscriptionData-…" data-id="heading-5"><a href="#FilterAPI-buildSubscriptionData-…" title="FilterAPI.buildSubscriptionData(…)"></a>FilterAPI.buildSubscriptionData(…)</h3>
    <pre><code> 1: public static SubscriptionData buildSubscriptionData(final String consumerGroup, String topic,
 2:     String subString) throws Exception {
 3:     SubscriptionData subscriptionData = new SubscriptionData();
 4:     subscriptionData.setTopic(topic);
 5:     subscriptionData.setSubString(subString);
 6:     // 处理订阅表达式
 7:     if (null == subString || subString.equals(SubscriptionData.SUB_ALL) || subString.length() == 0) {
 8:         subscriptionData.setSubString(SubscriptionData.SUB_ALL);
 9:     } else {
10:         String[] tags = subString.split("\\|\\|");
11:         if (tags.length &gt; 0) {
12:             for (String tag : tags) {
13:                 if (tag.length() &gt; 0) {
14:                     String trimString = tag.trim();
15:                     if (trimString.length() &gt; 0) {
16:                         subscriptionData.getTagsSet().add(trimString);
17:                         subscriptionData.getCodeSet().add(trimString.hashCode());
18:                     }
19:                 }
20:             }
21:         } else {
22:             throw new Exception("subString split error");
23:         }
24:     }
25: 
26:     return subscriptionData;
27: }
</code></pre>
    <ul>
        <li>说明 ：根据 <code>Topic</code> 和 订阅表达式 创建订阅数据</li>
        <li>subscriptionData.subVersion = System.currentTimeMillis()。</li>
    </ul>
    <h2 id="DefaultMQPushConsumer-registerMessageListener-…" data-id="heading-6"><a href="#DefaultMQPushConsumer-registerMessageListener-…" title="DefaultMQPushConsumer#registerMessageListener(…)"></a>DefaultMQPushConsumer#registerMessageListener(…)</h2>
    <pre><code>1: public void registerMessageListener(MessageListenerConcurrently messageListener) {
2:     this.messageListener = messageListener;
3:     this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);
4: }
</code></pre>
    <ul>
        <li>说明 ：注册消息监听器。</li>
    </ul>
    <h1 id="5、PushConsumer-消息队列分配" data-id="heading-7"><a href="#5、PushConsumer-消息队列分配" title="5、PushConsumer 消息队列分配"></a>5、PushConsumer 消息队列分配</h1>
    <p><img alt="RebalanceService&amp;PushConsumer分配队列" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/10/21/166937eae59622d8?imageView2/0/w/1280/h/960/ignore-error/1" data-width="1280" data-height="940" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;940&quot;&gt;&lt;/svg&gt;"></p>
    <h2 id="RebalanceService" data-id="heading-8"><a href="#RebalanceService" title="RebalanceService"></a>RebalanceService</h2>
    <pre><code> 1: public class RebalanceService extends ServiceThread {
 2: 
 3:     /**
 4:      * 等待间隔，单位：毫秒
 5:      */
 6:     private static long waitInterval =
 7:         Long.parseLong(System.getProperty(
 8:             "rocketmq.client.rebalance.waitInterval", "20000"));
 9: 
10:     private final Logger log = ClientLogger.getLog();
11:     /**
12:      * MQClient对象
13:      */
14:     private final MQClientInstance mqClientFactory;
15: 
16:     public RebalanceService(MQClientInstance mqClientFactory) {
17:         this.mqClientFactory = mqClientFactory;
18:     }
19: 
20:     @Override
21:     public void run() {
22:         log.info(this.getServiceName() + " service started");
23: 
24:         while (!this.isStopped()) {
25:             this.waitForRunning(waitInterval);
26:             this.mqClientFactory.doRebalance();
27:         }
28: 
29:         log.info(this.getServiceName() + " service end");
30:     }
31: 
32:     @Override
33:     public String getServiceName() {
34:         return RebalanceService.class.getSimpleName();
35:     }
36: }
</code></pre>
    <ul>
        <li>说明 ：均衡消息队列服务，负责分配当前 <code>Consumer</code> 可消费的消息队列( <code>MessageQueue</code> )。</li>
        <li>
            <p>第 26 行 ：调用 <code>MQClientInstance#doRebalance(...)</code> 分配消息队列。目前有三种情况情况下触发：</p>
            <ul>
                <li>如 <code>第 25 行</code> 等待超时，每 20s 调用一次。</li>
                <li><code>PushConsumer</code> 启动时，调用 <code>rebalanceService#wakeup(...)</code> 触发。</li>
                <li><code>Broker</code> 通知 <code>Consumer</code> 加入 或 移除时，<code>Consumer</code> 响应通知，调用 <code>rebalanceService#wakeup(...)</code> 触发。</li>
            </ul>
            <p>详细解析见：<a href="#mqclientinstancedorebalance">MQClientInstance#doRebalance(…)</a>。</p>
        </li>
    </ul>
    <h2 id="MQClientInstance-doRebalance-…" data-id="heading-9"><a href="#MQClientInstance-doRebalance-…" title="MQClientInstance#doRebalance(…)"></a>MQClientInstance#doRebalance(…)</h2>
    <pre><code> 1: public void doRebalance() {
 2:     for (Map.Entry&lt;String, MQConsumerInner&gt; entry : this.consumerTable.entrySet()) {
 3:         MQConsumerInner impl = entry.getValue();
 4:         if (impl != null) {
 5:             try {
 6:                 impl.doRebalance();
 7:             } catch (Throwable e) {
 8:                 log.error("doRebalance exception", e);
 9:             }
10:         }
11:     }
12: }
</code></pre>
    <ul>
        <li>说明 ：遍历当前 <code>Client</code> 包含的 <code>consumerTable</code>( <code>Consumer</code>集合 )，执行消息队列分配。</li>
        <li><strong>疑问</strong>：目前代码调试下来，<code>consumerTable</code> 只包含 <code>Consumer</code> 自己。😈有大大对这个疑问有解答的，烦请解答下。</li>
        <li>第 6 行 ：调用 <code>MQConsumerInner#doRebalance(...)</code> 进行队列分配。<code>DefaultMQPushConsumerImpl</code>、<code>DefaultMQPullConsumerImpl</code> 分别对该接口方法进行了实现。<code>DefaultMQPushConsumerImpl#doRebalance(...)</code> 详细解析见：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fdefaultmqpushconsumerimpldorebalance" target="_blank" rel="nofollow noopener noreferrer">DefaultMQPushConsumerImpl#doRebalance(…)</a>。</li>
    </ul>
    <h2 id="DefaultMQPushConsumerImpl-doRebalance-…" data-id="heading-10"><a href="#DefaultMQPushConsumerImpl-doRebalance-…" title="DefaultMQPushConsumerImpl#doRebalance(…)"></a>DefaultMQPushConsumerImpl#doRebalance(…)</h2>
    <pre><code>1: public void doRebalance() {
2:     if (!this.pause) {
3:         this.rebalanceImpl.doRebalance(this.isConsumeOrderly());
4:     }
5: }
</code></pre>
    <ul>
        <li>说明：执行消息队列分配。</li>
        <li>第 3 行 ：调用 <code>RebalanceImpl#doRebalance(...)</code> 进行队列分配。详细解析见：<a href="#rebalancepushimpldorebalance">RebalancePushImpl#doRebalance(…)</a>。</li>
    </ul>
    <h2 id="RebalanceImpl-doRebalance-…" data-id="heading-11"><a href="#RebalanceImpl-doRebalance-…" title="RebalanceImpl#doRebalance(…)"></a>RebalanceImpl#doRebalance(…)</h2>
    <pre><code> 1: /**
 2:  * 执行分配消息队列
 3:  *
 4:  * @param isOrder 是否顺序消息
 5:  */
 6: public void doRebalance(final boolean isOrder) {
 7:     // 分配每个 topic 的消息队列
 8:     Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();
 9:     if (subTable != null) {
10:         for (final Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) {
11:             final String topic = entry.getKey();
12:             try {
13:                 this.rebalanceByTopic(topic, isOrder);
14:             } catch (Throwable e) {
15:                 if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
16:                     log.warn("rebalanceByTopic Exception", e);
17:                 }
18:             }
19:         }
20:     }
21:     // 移除未订阅的topic对应的消息队列
22:     this.truncateMessageQueueNotMyTopic();
23: }
24: 
25: /**
26:  * 移除未订阅的消息队列
27:  */
28: private void truncateMessageQueueNotMyTopic() {
29:     Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();
30:     for (MessageQueue mq : this.processQueueTable.keySet()) {
31:         if (!subTable.containsKey(mq.getTopic())) {
32: 
33:             ProcessQueue pq = this.processQueueTable.remove(mq);
34:             if (pq != null) {
35:                 pq.setDropped(true);
36:                 log.info("doRebalance, {}, truncateMessageQueueNotMyTopic remove unnecessary mq, {}", consumerGroup, mq);
37:             }
38:         }
39:     }
40: }
</code></pre>
    <ul>
        <li><code>#doRebalance(...)</code> 说明 ：执行分配消息队列。
            <ul>
                <li>第 7 至 20 行 ：循环订阅主题集合( <code>subscriptionInner</code> )，分配每一个 <code>Topic</code> 的消息队列。</li>
                <li>第 22 行 ：移除未订阅的 <code>Topic</code> 的消息队列。</li>
            </ul>
        </li>
        <li><code>#truncateMessageQueueNotMyTopic(...)</code> 说明 ：移除未订阅的消息队列。当调用 <code>DefaultMQPushConsumer#unsubscribe(topic)</code> 时，只移除订阅主题集合( <code>subscriptionInner</code> )，对应消息队列移除在该方法。</li>
    </ul>
    <h3 id="RebalanceImpl-rebalanceByTopic-…" data-id="heading-12"><a href="#RebalanceImpl-rebalanceByTopic-…" title="RebalanceImpl#rebalanceByTopic(…)"></a>RebalanceImpl#rebalanceByTopic(…)</h3>
    <pre><code>  1: private void rebalanceByTopic(final String topic, final boolean isOrder) {
  2:     switch (messageModel) {
  3:         case BROADCASTING: {
  4:             Set&lt;MessageQueue&gt; mqSet = this.topicSubscribeInfoTable.get(topic);
  5:             if (mqSet != null) {
  6:                 boolean changed = this.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);
  7:                 if (changed) {
  8:                     this.messageQueueChanged(topic, mqSet, mqSet);
  9:                     log.info("messageQueueChanged {} {} {} {}", //
 10:                         consumerGroup, //
 11:                         topic, //
 12:                         mqSet, //
 13:                         mqSet);
 14:                 }
 15:             } else {
 16:                 log.warn("doRebalance, {}, but the topic[{}] not exist.", consumerGroup, topic);
 17:             }
 18:             break;
 19:         }
 20:         case CLUSTERING: {
 21:             // 获取 topic 对应的 队列 和 consumer信息
 22:             Set&lt;MessageQueue&gt; mqSet = this.topicSubscribeInfoTable.get(topic);
 23:             List&lt;String&gt; cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup);
 24:             if (null == mqSet) {
 25:                 if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
 26:                     log.warn("doRebalance, {}, but the topic[{}] not exist.", consumerGroup, topic);
 27:                 }
 28:             }
 29: 
 30:             if (null == cidAll) {
 31:                 log.warn("doRebalance, {} {}, get consumer id list failed", consumerGroup, topic);
 32:             }
 33: 
 34:             if (mqSet != null &amp;&amp; cidAll != null) {
 35:                 // 排序 消息队列 和 消费者数组。因为是在Client进行分配队列，排序后，各Client的顺序才能保持一致。
 36:                 List&lt;MessageQueue&gt; mqAll = new ArrayList&lt;&gt;();
 37:                 mqAll.addAll(mqSet);
 38: 
 39:                 Collections.sort(mqAll);
 40:                 Collections.sort(cidAll);
 41: 
 42:                 AllocateMessageQueueStrategy strategy = this.allocateMessageQueueStrategy;
 43: 
 44:                 // 根据 队列分配策略 分配消息队列
 45:                 List&lt;MessageQueue&gt; allocateResult;
 46:                 try {
 47:                     allocateResult = strategy.allocate(//
 48:                         this.consumerGroup, //
 49:                         this.mQClientFactory.getClientId(), //
 50:                         mqAll, //
 51:                         cidAll);
 52:                 } catch (Throwable e) {
 53:                     log.error("AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName={}", strategy.getName(),
 54:                         e);
 55:                     return;
 56:                 }
 57: 
 58:                 Set&lt;MessageQueue&gt; allocateResultSet = new HashSet&lt;&gt;();
 59:                 if (allocateResult != null) {
 60:                     allocateResultSet.addAll(allocateResult);
 61:                 }
 62: 
 63:                 // 更新消息队列
 64:                 boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);
 65:                 if (changed) {
 66:                     log.info(
 67:                         "rebalanced result changed. allocateMessageQueueStrategyName={}, group={}, topic={}, clientId={}, mqAllSize={}, cidAllSize={}, rebalanceResultSize={}, rebalanceResultSet={}",
 68:                         strategy.getName(), consumerGroup, topic, this.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),
 69:                         allocateResultSet.size(), allocateResultSet);
 70:                     this.messageQueueChanged(topic, mqSet, allocateResultSet);
 71:                 }
 72:             }
 73:             break;
 74:         }
 75:         default:
 76:             break;
 77:     }
 78: }
 79: 
 80: /**
 81:  * 当负载均衡时，更新 消息处理队列
 82:  * - 移除 在processQueueTable &amp;&amp; 不存在于 mqSet 里的消息队列
 83:  * - 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列
 84:  *
 85:  * @param topic Topic
 86:  * @param mqSet 负载均衡结果后的消息队列数组
 87:  * @param isOrder 是否顺序
 88:  * @return 是否变更
 89:  */
 90: private boolean updateProcessQueueTableInRebalance(final String topic, final Set&lt;MessageQueue&gt; mqSet, final boolean isOrder) {
 91:     boolean changed = false;
 92: 
 93:     // 移除 在processQueueTable &amp;&amp; 不存在于 mqSet 里的消息队列
 94:     Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = this.processQueueTable.entrySet().iterator();
 95:     while (it.hasNext()) { // TODO 待读：
 96:         Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();
 97:         MessageQueue mq = next.getKey();
 98:         ProcessQueue pq = next.getValue();
 99: 
100:         if (mq.getTopic().equals(topic)) {
101:             if (!mqSet.contains(mq)) { // 不包含的队列
102:                 pq.setDropped(true);
103:                 if (this.removeUnnecessaryMessageQueue(mq, pq)) {
104:                     it.remove();
105:                     changed = true;
106:                     log.info("doRebalance, {}, remove unnecessary mq, {}", consumerGroup, mq);
107:                 }
108:             } else if (pq.isPullExpired()) { // 队列拉取超时，进行清理
109:                 switch (this.consumeType()) {
110:                     case CONSUME_ACTIVELY:
111:                         break;
112:                     case CONSUME_PASSIVELY:
113:                         pq.setDropped(true);
114:                         if (this.removeUnnecessaryMessageQueue(mq, pq)) {
115:                             it.remove();
116:                             changed = true;
117:                             log.error("[BUG]doRebalance, {}, remove unnecessary mq, {}, because pull is pause, so try to fixed it",
118:                                 consumerGroup, mq);
119:                         }
120:                         break;
121:                     default:
122:                         break;
123:                 }
124:             }
125:         }
126:     }
127: 
128:     // 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列。
129:     List&lt;PullRequest&gt; pullRequestList = new ArrayList&lt;&gt;(); // 拉消息请求数组
130:     for (MessageQueue mq : mqSet) {
131:         if (!this.processQueueTable.containsKey(mq)) {
132:             if (isOrder &amp;&amp; !this.lock(mq)) {
133:                 log.warn("doRebalance, {}, add a new mq failed, {}, because lock failed", consumerGroup, mq);
134:                 continue;
135:             }
136: 
137:             this.removeDirtyOffset(mq);
138:             ProcessQueue pq = new ProcessQueue();
139:             long nextOffset = this.computePullFromWhere(mq);
140:             if (nextOffset &gt;= 0) {
141:                 ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);
142:                 if (pre != null) {
143:                     log.info("doRebalance, {}, mq already exists, {}", consumerGroup, mq);
144:                 } else {
145:                     log.info("doRebalance, {}, add a new mq, {}", consumerGroup, mq);
146:                     PullRequest pullRequest = new PullRequest();
147:                     pullRequest.setConsumerGroup(consumerGroup);
148:                     pullRequest.setNextOffset(nextOffset);
149:                     pullRequest.setMessageQueue(mq);
150:                     pullRequest.setProcessQueue(pq);
151:                     pullRequestList.add(pullRequest);
152:                     changed = true;
153:                 }
154:             } else {
155:                 log.warn("doRebalance, {}, add new mq failed, {}", consumerGroup, mq);
156:             }
157:         }
158:     }
159: 
160:     // 发起消息拉取请求
161:     this.dispatchPullRequest(pullRequestList);
162: 
163:     return changed;
164: }
</code></pre>
    <ul>
        <li><code>#rebalanceByTopic(...)</code> 说明 ：分配 <code>Topic</code> 的消息队列。
            <ul>
                <li>第 3 至 19 行 ：广播模式( <code>BROADCASTING</code> ) 下，分配 <code>Topic</code> 对应的<strong>所有</strong>消息队列。 </li>
                <li>第 20 至 74 行 ：集群模式( <code>CLUSTERING</code> ) 下，分配 <code>Topic</code> 对应的<strong>部分</strong>消息队列。
                    <ul>
                        <li>第 21 至 40 行 ：获取 <code>Topic</code> 对应的消息队列和消费者们，并对其进行排序。因为各 <code>Consumer</code> 是在本地分配消息队列，排序后才能保证各 <code>Consumer</code> 顺序一致。</li>
                        <li>第 42 至 61 行 ：根据 队列分配策略( <code>AllocateMessageQueueStrategy</code> ) 分配消息队列。详细解析见：<a href="#allocatemessagequeuestrategy">AllocateMessageQueueStrategy</a>。</li>
                        <li>第 63 至 72 行 ：更新 <code>Topic</code> 对应的消息队列。</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><code>#updateProcessQueueTableInRebalance(...)</code> 说明 ：当分配队列时，更新 <code>Topic</code> 对应的消息队列，并返回是否有变更。
            <ul>
                <li>第 93 至 126 行 ：移除不存在于分配的消息队列( <code>mqSet</code> ) 的 消息处理队列( <code>processQueueTable</code> )。
                    <ul>
                        <li>第 103 行 ：移除不需要的消息队列。详细解析见：<a href="#rebalancepushimplremoveunnecessarymessagequeue">RebalancePushImpl#removeUnnecessaryMessageQueue(…)</a>。</li>
                        <li>第 108 至 120 行 ：队列拉取超时，即 <code>当前时间 - 最后一次拉取消息时间 &gt; 120s</code> ( 120s 可配置)，判定发生 <strong>BUG</strong>，过久未进行消息拉取，移除消息队列。移除后，下面<strong>#新增队列逻辑#</strong>可以重新加入新的该消息队列。</li>
                    </ul>
                </li>
                <li>第 128 至 158 行 ：增加 分配的消息队列( <code>mqSet</code> ) 新增的消息队列。
                    <ul>
                        <li>第 132 至 135 行 ：<code>顺序消费</code> 相关跳过，详细解析见：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">《RocketMQ 源码分析 —— Message 顺序发送与消费》</a>。</li>
                        <li>第 137 行 ：移除消息队列的消费进度。</li>
                        <li>第 139 行 ：获取队列消费进度。详细解析见：<a href="#rebalancepushimplcomputepullfromwhere">RebalancePushImpl#computePullFromWhere(…)</a>。</li>
                        <li>第 140 至 156 行 ：<strong>添加新消费处理队列，添加消费拉取消息请求</strong>。</li>
                    </ul>
                </li>
                <li>第 161 行 ：<strong>发起新增的消息队列消息拉取请求</strong>。详细解析见：<a href="#rebalancepushimpldispatchpullrequest">RebalancePushImpl#dispatchPullRequest(…)</a>。</li>
            </ul>
        </li>
    </ul>
    <h3 id="RebalanceImpl-removeUnnecessaryMessageQueue-…" data-id="heading-13"><a href="#RebalanceImpl-removeUnnecessaryMessageQueue-…" title="RebalanceImpl#removeUnnecessaryMessageQueue(…)"></a>RebalanceImpl#removeUnnecessaryMessageQueue(…)</h3>
    <h4 id="RebalancePushImpl-removeUnnecessaryMessageQueue-…" data-id="heading-14"><a href="#RebalancePushImpl-removeUnnecessaryMessageQueue-…" title="RebalancePushImpl#removeUnnecessaryMessageQueue(…)"></a>RebalancePushImpl#removeUnnecessaryMessageQueue(…)</h4>
    <pre><code> 1: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {
 2:     // 同步队列的消费进度，并移除之。
 3:     this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);
 4:     this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);
 5:     // TODO 顺序消费
 6:     if (this.defaultMQPushConsumerImpl.isConsumeOrderly()
 7:         &amp;&amp; MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
 8:         try {
 9:             if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) {
10:                 try {
11:                     return this.unlockDelay(mq, pq);
12:                 } finally {
13:                     pq.getLockConsume().unlock();
14:                 }
15:             } else {
16:                 log.warn("[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}", //
17:                     mq, //
18:                     pq.getTryUnlockTimes());
19: 
20:                 pq.incTryUnlockTimes();
21:             }
22:         } catch (Exception e) {
23:             log.error("removeUnnecessaryMessageQueue Exception", e);
24:         }
25: 
26:         return false;
27:     }
28:     return true;
29: }
</code></pre>
    <ul>
        <li>说明 ：移除不需要的消息队列相关的信息，并返回是否移除成功。</li>
        <li>第 2 至 4 行 ：<strong>同步</strong>队列的消费进度，并移除之。</li>
        <li>第 5 至 27 行 ：<code>顺序消费</code> 相关跳过，详细解析见：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">《RocketMQ 源码分析 —— Message 顺序发送与消费》</a>。</li>
    </ul>
    <h4 id="PullConsumer-RebalancePullImpl-removeUnnecessaryMessageQueue-…" data-id="heading-15"><a href="#PullConsumer-RebalancePullImpl-removeUnnecessaryMessageQueue-…" title="[PullConsumer] RebalancePullImpl#removeUnnecessaryMessageQueue(…)"></a><code>[PullConsumer]</code> RebalancePullImpl#removeUnnecessaryMessageQueue(…)</h4>
    <pre><code>1: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {
2:     this.defaultMQPullConsumerImpl.getOffsetStore().persist(mq);
3:     this.defaultMQPullConsumerImpl.getOffsetStore().removeOffset(mq);
4:     return true;
5: }
</code></pre>
    <ul>
        <li>说明 ：移除不需要的消息队列相关的信息，并返回移除成功。和<code>RebalancePushImpl#removeUnnecessaryMessageQueue(...)</code>基本一致。</li>
    </ul>
    <h3 id="RebalancePushImpl-dispatchPullRequest-…" data-id="heading-16"><a href="#RebalancePushImpl-dispatchPullRequest-…" title="RebalancePushImpl#dispatchPullRequest(…)"></a>RebalancePushImpl#dispatchPullRequest(…)</h3>
    <pre><code>1: public void dispatchPullRequest(List&lt;PullRequest&gt; pullRequestList) {
2:     for (PullRequest pullRequest : pullRequestList) {
3:         this.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);
4:         log.info("doRebalance, {}, add a new pull request {}", consumerGroup, pullRequest);
5:     }
6: }
</code></pre>
    <ul>
        <li>说明 ：发起消息拉取请求。该调用是<code>PushConsumer</code>不断不断不断拉取消息的起点。</li>
    </ul>
    <h4 id="DefaultMQPushConsumerImpl-executePullRequestImmediately-…" data-id="heading-17"><a href="#DefaultMQPushConsumerImpl-executePullRequestImmediately-…" title="DefaultMQPushConsumerImpl#executePullRequestImmediately(…)"></a>DefaultMQPushConsumerImpl#executePullRequestImmediately(…)</h4>
    <pre><code>1: public void executePullRequestImmediately(final PullRequest pullRequest) {
2:     this.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);
3: }
</code></pre>
    <ul>
        <li>说明 ：提交拉取请求。提交后，<code>PullMessageService</code> <strong>异步执行</strong>，<strong>非阻塞</strong>。详细解析见：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fpullmessageservice" target="_blank" rel="nofollow noopener noreferrer">PullMessageService</a>。</li>
    </ul>
    <h3 id="AllocateMessageQueueStrategy" data-id="heading-18"><a href="#AllocateMessageQueueStrategy" title="AllocateMessageQueueStrategy"></a>AllocateMessageQueueStrategy</h3>
    <p><img alt="AllocateMessageQueueStrategy类图" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/10/21/166937eae5b19d65?imageView2/0/w/1280/h/960/ignore-error/1" data-width="1280" data-height="786" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;786&quot;&gt;&lt;/svg&gt;"></p>
    <h4 id="AllocateMessageQueueAveragely" data-id="heading-19"><a href="#AllocateMessageQueueAveragely" title="AllocateMessageQueueAveragely"></a>AllocateMessageQueueAveragely</h4>
    <pre><code> 1: public class AllocateMessageQueueAveragely implements AllocateMessageQueueStrategy {
 2:     private final Logger log = ClientLogger.getLog();
 3: 
 4:     @Override
 5:     public List&lt;MessageQueue&gt; allocate(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,
 6:         List&lt;String&gt; cidAll) {
 7:         // 校验参数是否正确
 8:         if (currentCID == null || currentCID.length() &lt; 1) {
 9:             throw new IllegalArgumentException("currentCID is empty");
10:         }
11:         if (mqAll == null || mqAll.isEmpty()) {
12:             throw new IllegalArgumentException("mqAll is null or mqAll empty");
13:         }
14:         if (cidAll == null || cidAll.isEmpty()) {
15:             throw new IllegalArgumentException("cidAll is null or cidAll empty");
16:         }
17: 
18:         List&lt;MessageQueue&gt; result = new ArrayList&lt;&gt;();
19:         if (!cidAll.contains(currentCID)) {
20:             log.info("[BUG] ConsumerGroup: {} The consumerId: {} not in cidAll: {}",
21:                 consumerGroup,
22:                 currentCID,
23:                 cidAll);
24:             return result;
25:         }
26:         // 平均分配
27:         int index = cidAll.indexOf(currentCID); // 第几个consumer。
28:         int mod = mqAll.size() % cidAll.size(); // 余数，即多少消息队列无法平均分配。
29:         int averageSize =
30:             mqAll.size() &lt;= cidAll.size() ? 1 : (mod &gt; 0 &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()
31:                 + 1 : mqAll.size() / cidAll.size());
32:         int startIndex = (mod &gt; 0 &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod; // 有余数的情况下，[0, mod) 平分余数，即每consumer多分配一个节点；第index开始，跳过前mod余数。
33:         int range = Math.min(averageSize, mqAll.size() - startIndex); // 分配队列数量。之所以要Math.min()的原因是，mqAll.size() &lt;= cidAll.size()，部分consumer分配不到消息队列。
34:         for (int i = 0; i &lt; range; i++) {
35:             result.add(mqAll.get((startIndex + i) % mqAll.size()));
36:         }
37:         return result;
38:     }
39: 
40:     @Override
41:     public String getName() {
42:         return "AVG";
43:     }
44: }
</code></pre>
    <ul>
        <li>说明 ：<strong>平均</strong>分配队列策略。</li>
        <li>第 7 至 25 行 ：参数校验。</li>
        <li>第 26 至 36 行 ：平均分配消息队列。
            <ul>
                <li>第 27 行 ：<code>index</code> ：当前 <code>Consumer</code> 在消费集群里是第几个。这里就是为什么需要对传入的 <code>cidAll</code> 参数必须进行排序的原因。如果不排序，<code>Consumer</code> 在本地计算出来的 <code>index</code> 无法一致，影响计算结果。</li>
                <li>第 28 行 ：<code>mod</code> ：余数，即多少消息队列无法平均分配。</li>
                <li>第 29 至 31 行 ：<code>averageSize</code> ：代码可以简化成 <code>(mod &gt; 0 &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size() + 1 : mqAll.size() / cidAll.size())</code>。
                    <ul>
                        <li><code>[ 0, mod )</code> ：<code>mqAll.size() / cidAll.size() + 1</code>。前面 <code>mod</code> 个 <code>Consumer</code> 平分余数，多获得 1 个消息队列。</li>
                        <li><code>[ mod, cidAll.size() )</code> ：<code>mqAll.size() / cidAll.size()</code>。</li>
                    </ul>
                </li>
                <li>第 32 行 ：<code>startIndex</code> ：<code>Consumer</code> 分配消息队列开始位置。</li>
                <li>第 33 行 ：<code>range</code> ：分配队列数量。之所以要 <code>Math#min(...)</code> 的原因：当 <code>mqAll.size() &lt;= cidAll.size()</code> 时，最后几个 <code>Consumer</code> 分配不到消息队列。</li>
                <li>第 34 至 36 行 ：生成分配消息队列结果。</li>
            </ul>
        </li>
        <li>举个例子：</li>
    </ul>
    <p>固定消息队列长度为<strong>4</strong>。</p>
    <table>
        <thead>
            <tr>
                <th></th>
                <th>Consumer <em> 2 </em>可以整除*</th>
                <th>Consumer <em> 3 </em>不可整除*</th>
                <th>Consumer <em> 5 </em>无法都分配*</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>消息队列[0]</td>
                <td>Consumer[0]</td>
                <td>Consumer[0]</td>
                <td>Consumer[0]</td>
            </tr>
            <tr>
                <td>消息队列[1]</td>
                <td>Consumer[0]</td>
                <td>Consumer[0]</td>
                <td>Consumer[1]</td>
            </tr>
            <tr>
                <td>消息队列[2]</td>
                <td>Consumer[1]</td>
                <td>Consumer[1]</td>
                <td>Consumer[2]</td>
            </tr>
            <tr>
                <td>消息队列[3]</td>
                <td>Consumer[1]</td>
                <td>Consumer[2]</td>
                <td>Consumer[3]</td>
            </tr>
        </tbody>
    </table>
    <h4 id="AllocateMessageQueueByMachineRoom" data-id="heading-20"><a href="#AllocateMessageQueueByMachineRoom" title="AllocateMessageQueueByMachineRoom"></a>AllocateMessageQueueByMachineRoom</h4>
    <pre><code> 1: public class AllocateMessageQueueByMachineRoom implements AllocateMessageQueueStrategy {
 2:     /**
 3:      * 消费者消费brokerName集合
 4:      */
 5:     private Set&lt;String&gt; consumeridcs;
 6: 
 7:     @Override
 8:     public List&lt;MessageQueue&gt; allocate(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,
 9:         List&lt;String&gt; cidAll) {
10:         // 参数校验
11:         List&lt;MessageQueue&gt; result = new ArrayList&lt;MessageQueue&gt;();
12:         int currentIndex = cidAll.indexOf(currentCID);
13:         if (currentIndex &lt; 0) {
14:             return result;
15:         }
16:         // 计算符合当前配置的消费者数组('consumeridcs')对应的消息队列
17:         List&lt;MessageQueue&gt; premqAll = new ArrayList&lt;MessageQueue&gt;();
18:         for (MessageQueue mq : mqAll) {
19:             String[] temp = mq.getBrokerName().split("@");
20:             if (temp.length == 2 &amp;&amp; consumeridcs.contains(temp[0])) {
21:                 premqAll.add(mq);
22:             }
23:         }
24:         // 平均分配
25:         int mod = premqAll.size() / cidAll.size();
26:         int rem = premqAll.size() % cidAll.size();
27:         int startIndex = mod * currentIndex;
28:         int endIndex = startIndex + mod;
29:         for (int i = startIndex; i &lt; endIndex; i++) {
30:             result.add(mqAll.get(i));
31:         }
32:         if (rem &gt; currentIndex) {
33:             result.add(premqAll.get(currentIndex + mod * cidAll.size()));
34:         }
35:         return result;
36:     }
37: 
38:     @Override
39:     public String getName() {
40:         return "MACHINE_ROOM";
41:     }
42: 
43:     public Set&lt;String&gt; getConsumeridcs() {
44:         return consumeridcs;
45:     }
46: 
47:     public void setConsumeridcs(Set&lt;String&gt; consumeridcs) {
48:         this.consumeridcs = consumeridcs;
49:     }
50: }
</code></pre>
    <ul>
        <li>说明 ：<strong>平均</strong>分配<strong>可消费的</strong> <code>Broker</code> 对应的消息队列。</li>
        <li>第 7 至 15 行 ：参数校验。</li>
        <li>第 16 至 23 行 ：计算<strong>可消费的</strong> <code>Broker</code> 对应的消息队列。</li>
        <li>第 25 至 34 行 ：平均分配消息队列。该<strong>平均分配</strong>方式和 <code>AllocateMessageQueueAveragely</code> 略有不同，其是将多余的结尾部分分配给前 <code>rem</code> 个 <code>Consumer</code>。</li>
        <li>疑问：使用该分配策略时，<code>Consumer</code> 和 <code>Broker</code> 分配需要怎么配置。😈等研究<strong>主从</strong>相关源码时，仔细考虑下。</li>
    </ul>
    <h4 id="AllocateMessageQueueAveragelyByCircle" data-id="heading-21"><a href="#AllocateMessageQueueAveragelyByCircle" title="AllocateMessageQueueAveragelyByCircle"></a>AllocateMessageQueueAveragelyByCircle</h4>
    <pre><code>  1: public class AllocateMessageQueueAveragelyByCircle implements AllocateMessageQueueStrategy {
 2:     private final Logger log = ClientLogger.getLog();
 3: 
 4:     @Override
 5:     public List&lt;MessageQueue&gt; allocate(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,
 6:         List&lt;String&gt; cidAll) {
 7:         // 校验参数是否正确
 8:         if (currentCID == null || currentCID.length() &lt; 1) {
 9:             throw new IllegalArgumentException("currentCID is empty");
10:         }
11:         if (mqAll == null || mqAll.isEmpty()) {
12:             throw new IllegalArgumentException("mqAll is null or mqAll empty");
13:         }
14:         if (cidAll == null || cidAll.isEmpty()) {
15:             throw new IllegalArgumentException("cidAll is null or cidAll empty");
16:         }
17: 
18:         List&lt;MessageQueue&gt; result = new ArrayList&lt;MessageQueue&gt;();
19:         if (!cidAll.contains(currentCID)) {
20:             log.info("[BUG] ConsumerGroup: {} The consumerId: {} not in cidAll: {}",
21:                 consumerGroup,
22:                 currentCID,
23:                 cidAll);
24:             return result;
25:         }
26: 
27:         // 环状分配
28:         int index = cidAll.indexOf(currentCID);
29:         for (int i = index; i &lt; mqAll.size(); i++) {
30:             if (i % cidAll.size() == index) {
31:                 result.add(mqAll.get(i));
32:             }
33:         }
34:         return result;
35:     }
36: 
37:     @Override
38:     public String getName() {
39:         return "AVG_BY_CIRCLE";
40:     }
41: }
</code></pre>
    <ul>
        <li>说明 ：环状分配消息队列。</li>
    </ul>
    <h4 id="AllocateMessageQueueByConfig" data-id="heading-22"><a href="#AllocateMessageQueueByConfig" title="AllocateMessageQueueByConfig"></a>AllocateMessageQueueByConfig</h4>
    <pre><code> 1: public class AllocateMessageQueueByConfig implements AllocateMessageQueueStrategy {
 2:     private List&lt;MessageQueue&gt; messageQueueList;
 3: 
 4:     @Override
 5:     public List&lt;MessageQueue&gt; allocate(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,
 6:         List&lt;String&gt; cidAll) {
 7:         return this.messageQueueList;
 8:     }
 9: 
10:     @Override
11:     public String getName() {
12:         return "CONFIG";
13:     }
14: 
15:     public List&lt;MessageQueue&gt; getMessageQueueList() {
16:         return messageQueueList;
17:     }
18: 
19:     public void setMessageQueueList(List&lt;MessageQueue&gt; messageQueueList) {
20:         this.messageQueueList = messageQueueList;
21:     }
22: }
</code></pre>
    <ul>
        <li>说明 ：分配<strong>配置的</strong>消息队列。</li>
        <li>疑问 ：<em>该分配策略的使用场景。</em></li>
    </ul>
    <h1 id="5、PushConsumer-消费进度读取" data-id="heading-23"><a href="#5、PushConsumer-消费进度读取" title="5、PushConsumer 消费进度读取"></a>5、PushConsumer 消费进度读取</h1>
    <h2 id="RebalancePushImpl-computePullFromWhere-…" data-id="heading-24"><a href="#RebalancePushImpl-computePullFromWhere-…" title="RebalancePushImpl#computePullFromWhere(…)"></a>RebalancePushImpl#computePullFromWhere(…)</h2>
    <pre><code> 1: public long computePullFromWhere(MessageQueue mq) {
 2:     long result = -1;
 3:     final ConsumeFromWhere consumeFromWhere = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeFromWhere();
 4:     final OffsetStore offsetStore = this.defaultMQPushConsumerImpl.getOffsetStore();
 5:     switch (consumeFromWhere) {
 6:         case CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST: // 废弃
 7:         case CONSUME_FROM_MIN_OFFSET: // 废弃
 8:         case CONSUME_FROM_MAX_OFFSET: // 废弃
 9:         case CONSUME_FROM_LAST_OFFSET: {
10:             long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);
11:             if (lastOffset &gt;= 0) {
12:                 result = lastOffset;
13:             }
14:             // First start,no offset
15:             else if (-1 == lastOffset) {
16:                 if (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
17:                     result = 0L;
18:                 } else {
19:                     try {
20:                         result = this.mQClientFactory.getMQAdminImpl().maxOffset(mq);
21:                     } catch (MQClientException e) {
22:                         result = -1;
23:                     }
24:                 }
25:             } else {
26:                 result = -1;
27:             }
28:             break;
29:         }
30:         case CONSUME_FROM_FIRST_OFFSET: {
31:             long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);
32:             if (lastOffset &gt;= 0) {
33:                 result = lastOffset;
34:             } else if (-1 == lastOffset) {
35:                 result = 0L;
36:             } else {
37:                 result = -1;
38:             }
39:             break;
40:         }
41:         case CONSUME_FROM_TIMESTAMP: {
42:             long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);
43:             if (lastOffset &gt;= 0) {
44:                 result = lastOffset;
45:             } else if (-1 == lastOffset) {
46:                 if (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
47:                     try {
48:                         result = this.mQClientFactory.getMQAdminImpl().maxOffset(mq);
49:                     } catch (MQClientException e) {
50:                         result = -1;
51:                     }
52:                 } else {
53:                     try {
54:                         long timestamp = UtilAll.parseDate(this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeTimestamp(),
55:                             UtilAll.YYYY_MMDD_HHMMSS).getTime();
56:                         result = this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);
57:                     } catch (MQClientException e) {
58:                         result = -1;
59:                     }
60:                 }
61:             } else {
62:                 result = -1;
63:             }
64:             break;
65:         }
66: 
67:         default:
68:             break;
69:     }
70: 
71:     return result;
72: }
</code></pre>
    <ul>
        <li>说明 ：计算消息队列开始消费位置。</li>
        <li><code>PushConsumer</code> 读取消费进度有三种选项：
            <ul>
                <li><code>CONSUME_FROM_LAST_OFFSET</code> ：第 6 至 29 行 ：一个新的消费集群第一次启动从<strong>队列的最后位置</strong>开始消费。<strong>后续再启动接着上次消费的进度开始消费</strong>。</li>
                <li><code>CONSUME_FROM_FIRST_OFFSET</code> ：第 30 至 40 行 ：一个新的消费集群第一次启动从队列的<strong>最前位置</strong>开始消费。<strong>后续再启动接着上次消费的进度开始消费</strong>。</li>
                <li><code>CONSUME_FROM_TIMESTAMP</code> ：第 41 至 65 行 ：一个新的消费集群第一次启动从<strong>指定时间点</strong>开始消费。<strong>后续再启动接着上次消费的进度开始消费</strong>。</li>
            </ul>
        </li>
    </ul>
    <h2 id="PullConsumer-RebalancePullImpl-computePullFromWhere-…" data-id="heading-25"><a href="#PullConsumer-RebalancePullImpl-computePullFromWhere-…" title="[PullConsumer] RebalancePullImpl#computePullFromWhere(…)"></a><code>[PullConsumer]</code> RebalancePullImpl#computePullFromWhere(…)</h2>
    <p>暂时跳过。😈</p>
    <h1 id="6、PushConsumer-拉取消息" data-id="heading-26"><a href="#6、PushConsumer-拉取消息" title="6、PushConsumer 拉取消息"></a>6、PushConsumer 拉取消息</h1>
    <p><img alt="DefaultMQPushConsumerImpl拉取消息" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/10/21/166937ec382cfa0f?imageView2/0/w/1280/h/960/ignore-error/1" data-width="1280" data-height="874" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;874&quot;&gt;&lt;/svg&gt;"></p>
    <h2 id="PullMessageService" data-id="heading-27"><a href="#PullMessageService" title="PullMessageService"></a>PullMessageService</h2>
    <pre><code>  1: public class PullMessageService extends ServiceThread {
  2:     private final Logger log = ClientLogger.getLog();
  3:     /**
  4:      * 拉取消息请求队列
  5:      */
  6:     private final LinkedBlockingQueue&lt;PullRequest&gt; pullRequestQueue = new LinkedBlockingQueue&lt;&gt;();
  7:     /**
  8:      * MQClient对象
  9:      */
 10:     private final MQClientInstance mQClientFactory;
 11:     /**
 12:      * 定时器。用于延迟提交拉取请求
 13:      */
 14:     private final ScheduledExecutorService scheduledExecutorService = Executors
 15:         .newSingleThreadScheduledExecutor(new ThreadFactory() {
 16:             @Override
 17:             public Thread newThread(Runnable r) {
 18:                 return new Thread(r, "PullMessageServiceScheduledThread");
 19:             }
 20:         });
 21: 
 22:     public PullMessageService(MQClientInstance mQClientFactory) {
 23:         this.mQClientFactory = mQClientFactory;
 24:     }
 25: 
 26:     /**
 27:      * 执行延迟拉取消息请求
 28:      *
 29:      * @param pullRequest 拉取消息请求
 30:      * @param timeDelay 延迟时长
 31:      */
 32:     public void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) {
 33:         this.scheduledExecutorService.schedule(new Runnable() {
 34: 
 35:             @Override
 36:             public void run() {
 37:                 PullMessageService.this.executePullRequestImmediately(pullRequest);
 38:             }
 39:         }, timeDelay, TimeUnit.MILLISECONDS);
 40:     }
 41: 
 42:     /**
 43:      * 执行立即拉取消息请求
 44:      *
 45:      * @param pullRequest 拉取消息请求
 46:      */
 47:     public void executePullRequestImmediately(final PullRequest pullRequest) {
 48:         try {
 49:             this.pullRequestQueue.put(pullRequest);
 50:         } catch (InterruptedException e) {
 51:             log.error("executePullRequestImmediately pullRequestQueue.put", e);
 52:         }
 53:     }
 54: 
 55:     /**
 56:      * 执行延迟任务
 57:      *
 58:      * @param r 任务
 59:      * @param timeDelay 延迟时长
 60:      */
 61:     public void executeTaskLater(final Runnable r, final long timeDelay) {
 62:         this.scheduledExecutorService.schedule(r, timeDelay, TimeUnit.MILLISECONDS);
 63:     }
 64: 
 65:     public ScheduledExecutorService getScheduledExecutorService() {
 66:         return scheduledExecutorService;
 67:     }
 68: 
 69:     /**
 70:      * 拉取消息
 71:      *
 72:      * @param pullRequest 拉取消息请求
 73:      */
 74:     private void pullMessage(final PullRequest pullRequest) {
 75:         final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());
 76:         if (consumer != null) {
 77:             DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;
 78:             impl.pullMessage(pullRequest);
 79:         } else {
 80:             log.warn("No matched consumer for the PullRequest {}, drop it", pullRequest);
 81:         }
 82:     }
 83: 
 84:     @Override
 85:     public void run() {
 86:         log.info(this.getServiceName() + " service started");
 87: 
 88:         while (!this.isStopped()) {
 89:             try {
 90:                 PullRequest pullRequest = this.pullRequestQueue.take();
 91:                 if (pullRequest != null) {
 92:                     this.pullMessage(pullRequest);
 93:                 }
 94:             } catch (InterruptedException e) {
 95:             } catch (Exception e) {
 96:                 log.error("Pull Message Service Run Method exception", e);
 97:             }
 98:         }
 99: 
100:         log.info(this.getServiceName() + " service end");
101:     }
102: 
103:     @Override
104:     public String getServiceName() {
105:         return PullMessageService.class.getSimpleName();
106:     }
107: 
108: }
</code></pre>
    <ul>
        <li>说明 ：拉取消息服务，不断不断不断从 <code>Broker</code> 拉取消息，并提交消费任务到 <code>ConsumeMessageService</code>。</li>
        <li><code>#executePullRequestLater(...)</code> ：第 26 至 40 行 ： 提交<strong>延迟</strong>拉取消息请求。</li>
        <li><code>#executePullRequestImmediately(...)</code> ：第 42 至 53 行 ：提交<strong>立即</strong>拉取消息请求。</li>
        <li><code>#executeTaskLater(...)</code> ：第 55 至 63 行 ：提交<strong>延迟任务</strong>。</li>
        <li><code>#pullMessage(...)</code> ：第 69 至 82 行 ：执行拉取消息逻辑。详细解析见：<a href="#defaultmqpushconsumerimplpullmessage">DefaultMQPushConsumerImpl#pullMessage(…)</a>。</li>
        <li><code>#run(...)</code> ：第 84 至 101 行 ：循环拉取消息请求队列( <code>pullRequestQueue</code> )，进行消息拉取。</li>
    </ul>
    <h2 id="DefaultMQPushConsumerImpl-pullMessage-…" data-id="heading-28"><a href="#DefaultMQPushConsumerImpl-pullMessage-…" title="DefaultMQPushConsumerImpl#pullMessage(…)"></a>DefaultMQPushConsumerImpl#pullMessage(…)</h2>
    <pre><code>  1: public void pullMessage(final PullRequest pullRequest) {
  2:     final ProcessQueue processQueue = pullRequest.getProcessQueue();
  3:     if (processQueue.isDropped()) {
  4:         log.info("the pull request[{}] is dropped.", pullRequest.toString());
  5:         return;
  6:     }
  7: 
  8:     // 设置队列最后拉取消息时间
  9:     pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());
 10: 
 11:     // 判断consumer状态是否运行中。如果不是，则延迟拉取消息。
 12:     try {
 13:         this.makeSureStateOK();
 14:     } catch (MQClientException e) {
 15:         log.warn("pullMessage exception, consumer state not ok", e);
 16:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);
 17:         return;
 18:     }
 19: 
 20:     // 判断是否暂停中。
 21:     if (this.isPause()) {
 22:         log.warn("consumer was paused, execute pull request later. instanceName={}, group={}", this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());
 23:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);
 24:         return;
 25:     }
 26: 
 27:     // 判断是否超过最大持有消息数量。默认最大值为1000。
 28:     long size = processQueue.getMsgCount().get();
 29:     if (size &gt; this.defaultMQPushConsumer.getPullThresholdForQueue()) {
 30:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); // 提交延迟消息拉取请求。50ms。
 31:         if ((flowControlTimes1++ % 1000) == 0) {
 32:             log.warn(
 33:                 "the consumer message buffer is full, so do flow control, minOffset={}, maxOffset={}, size={}, pullRequest={}, flowControlTimes={}",
 34:                 processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), size, pullRequest, flowControlTimes1);
 35:         }
 36:         return;
 37:     }
 38: 
 39:     if (!this.consumeOrderly) { // 判断消息跨度是否过大。
 40:         if (processQueue.getMaxSpan() &gt; this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {
 41:             this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); // 提交延迟消息拉取请求。50ms。
 42:             if ((flowControlTimes2++ % 1000) == 0) {
 43:                 log.warn(
 44:                     "the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}",
 45:                     processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),
 46:                     pullRequest, flowControlTimes2);
 47:             }
 48:             return;
 49:         }
 50:     } else { // TODO 顺序消费
 51:         if (processQueue.isLocked()) {
 52:             if (!pullRequest.isLockedFirst()) {
 53:                 final long offset = this.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());
 54:                 boolean brokerBusy = offset &lt; pullRequest.getNextOffset();
 55:                 log.info("the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}",
 56:                     pullRequest, offset, brokerBusy);
 57:                 if (brokerBusy) {
 58:                     log.info("[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}",
 59:                         pullRequest, offset);
 60:                 }
 61: 
 62:                 pullRequest.setLockedFirst(true);
 63:                 pullRequest.setNextOffset(offset);
 64:             }
 65:         } else {
 66:             this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);
 67:             log.info("pull message later because not locked in broker, {}", pullRequest);
 68:             return;
 69:         }
 70:     }
 71: 
 72:     // 获取Topic 对应的订阅信息。若不存在，则延迟拉取消息
 73:     final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());
 74:     if (null == subscriptionData) {
 75:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);
 76:         log.warn("find the consumer's subscription failed, {}", pullRequest);
 77:         return;
 78:     }
 79: 
 80:     final long beginTimestamp = System.currentTimeMillis();
 81: 
 82:     PullCallback pullCallback = new PullCallback() {
 83:         @Override
 84:         public void onSuccess(PullResult pullResult) {
 85:             if (pullResult != null) {
 86:                 pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,
 87:                     subscriptionData);
 88: 
 89:                 switch (pullResult.getPullStatus()) {
 90:                     case FOUND:
 91:                         // 设置下次拉取消息队列位置
 92:                         long prevRequestOffset = pullRequest.getNextOffset();
 93:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());
 94: 
 95:                         // 统计
 96:                         long pullRT = System.currentTimeMillis() - beginTimestamp;
 97:                         DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),
 98:                             pullRequest.getMessageQueue().getTopic(), pullRT);
 99: 
100:                         long firstMsgOffset = Long.MAX_VALUE;
101:                         if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) {
102:                             DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
103:                         } else {
104:                             firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset();
105: 
106:                             // 统计
107:                             DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),
108:                                 pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());
109: 
110:                             // 提交拉取到的消息到消息处理队列
111:                             boolean dispathToConsume = processQueue.putMessage(pullResult.getMsgFoundList());
112: 
113:                             // 提交消费请求
114:                             DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(//
115:                                 pullResult.getMsgFoundList(), //
116:                                 processQueue, //
117:                                 pullRequest.getMessageQueue(), //
118:                                 dispathToConsume);
119: 
120:                             // 提交下次拉取消息请求
121:                             if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() &gt; 0) {
122:                                 DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,
123:                                     DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());
124:                             } else {
125:                                 DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
126:                             }
127:                         }
128: 
129:                         // 下次拉取消息队列位置小于上次拉取消息队列位置 或者 第一条消息的消息队列位置小于上次拉取消息队列位置，则判定为BUG，输出log
130:                         if (pullResult.getNextBeginOffset() &lt; prevRequestOffset//
131:                             || firstMsgOffset &lt; prevRequestOffset) {
132:                             log.warn(
133:                                 "[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}", //
134:                                 pullResult.getNextBeginOffset(), //
135:                                 firstMsgOffset, //
136:                                 prevRequestOffset);
137:                         }
138: 
139:                         break;
140:                     case NO_NEW_MSG:
141:                         // 设置下次拉取消息队列位置
142:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());
143: 
144:                         // 持久化消费进度
145:                         DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);
146: 
147:                         // 立即提交拉取消息请求
148:                         DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
149:                         break;
150:                     case NO_MATCHED_MSG:
151:                         // 设置下次拉取消息队列位置
152:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());
153: 
154:                         // 持久化消费进度
155:                         DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);
156: 
157:                         // 提交立即拉取消息请求
158:                         DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
159:                         break;
160:                     case OFFSET_ILLEGAL:
161:                         log.warn("the pull request offset illegal, {} {}", //
162:                             pullRequest.toString(), pullResult.toString());
163:                         // 设置下次拉取消息队列位置
164:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());
165: 
166:                         // 设置消息处理队列为dropped
167:                         pullRequest.getProcessQueue().setDropped(true);
168: 
169:                         // 提交延迟任务，进行消费处理队列移除。不立即移除的原因：可能有地方正在使用，避免受到影响。
170:                         DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() {
171: 
172:                             @Override
173:                             public void run() {
174:                                 try {
175:                                     // 更新消费进度，同步消费进度到Broker
176:                                     DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(),
177:                                         pullRequest.getNextOffset(), false);
178:                                     DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue());
179: 
180:                                     // 移除消费处理队列
181:                                     DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());
182: 
183:                                     log.warn("fix the pull request offset, {}", pullRequest);
184:                                 } catch (Throwable e) {
185:                                     log.error("executeTaskLater Exception", e);
186:                                 }
187:                             }
188:                         }, 10000);
189:                         break;
190:                     default:
191:                         break;
192:                 }
193:             }
194:         }
195: 
196:         @Override
197:         public void onException(Throwable e) {
198:             if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
199:                 log.warn("execute the pull request exception", e);
200:             }
201: 
202:             // 提交延迟拉取消息请求
203:             DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);
204:         }
205:     };
206: 
207:     // 集群消息模型下，计算提交的消费进度。
208:     boolean commitOffsetEnable = false;
209:     long commitOffsetValue = 0L;
210:     if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) {
211:         commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);
212:         if (commitOffsetValue &gt; 0) {
213:             commitOffsetEnable = true;
214:         }
215:     }
216: 
217:     // 计算请求的 订阅表达式 和 是否进行filtersrv过滤消息
218:     String subExpression = null;
219:     boolean classFilter = false;
220:     SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());
221:     if (sd != null) {
222:         if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) {
223:             subExpression = sd.getSubString();
224:         }
225: 
226:         classFilter = sd.isClassFilterMode();
227:     }
228: 
229:     // 计算拉取消息系统标识
230:     int sysFlag = PullSysFlag.buildSysFlag(//
231:         commitOffsetEnable, // commitOffset
232:         true, // suspend
233:         subExpression != null, // subscription
234:         classFilter // class filter
235:     );
236: 
237:     // 执行拉取。如果拉取请求发生异常时，提交延迟拉取消息请求。
238:     try {
239:         this.pullAPIWrapper.pullKernelImpl(//
240:             pullRequest.getMessageQueue(), // 1
241:             subExpression, // 2
242:             subscriptionData.getSubVersion(), // 3
243:             pullRequest.getNextOffset(), // 4
244:             this.defaultMQPushConsumer.getPullBatchSize(), // 5
245:             sysFlag, // 6
246:             commitOffsetValue, // 7
247:             BROKER_SUSPEND_MAX_TIME_MILLIS, // 8
248:             CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, // 9
249:             CommunicationMode.ASYNC, // 10
250:             pullCallback// 11
251:         );
252:     } catch (Exception e) {
253:         log.error("pullKernelImpl exception", e);
254:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);
255:     }
256: }
257: 
258: private void correctTagsOffset(final PullRequest pullRequest) {
259:     if (0L == pullRequest.getProcessQueue().getMsgCount().get()) {
260:         this.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), true);
261:     }
262: }
</code></pre>
    <ul>
        <li><code>#pullMessage(...)</code> 说明 ：拉取消息。
            <ul>
                <li>第 3 至 6 行 ：消息处理队列已经终止，不进行消息拉取。</li>
                <li>第 9 行 ：设置消息处理队列最后拉取消息时间。</li>
                <li>第 11 至 18 行 ：<code>Consumer</code> 未处于运行中状态，不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>
                <li>第 20 至 25 行 ： <code>Consumer</code> 处于暂停中，不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>
                <li>第 27 至 37 行 ：消息处理队列持有消息超过最大允许值（默认：1000条），不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>
                <li>第 39 至 49 行 ：<code>Consumer</code> 为<strong>并发消费</strong> 并且 消息队列持有消息跨度过大（消息跨度 = 持有消息最后一条和第一条的消息位置差，默认：2000），不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>
                <li>第 50 至 70 行 ：<code>顺序消费</code> 相关跳过，详细解析见：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-send-and-consume-orderly%2F" target="_blank" rel="nofollow noopener noreferrer">《RocketMQ 源码分析 —— Message 顺序发送与消费》</a>。</li>
                <li>第 72 至 78 行 ：<code>Topic</code> 对应的订阅信息不存在，不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>
                <li>第 222 至 224 行 ：判断请求是否使用 <code>Consumer</code> <strong>本地</strong>的订阅信息( <code>SubscriptionData</code> )，而不使用 <code>Broker</code> 里的订阅信息。详细解析见：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-first%2F%23PullMessageProcessor-processRequest-%E2%80%A6" target="_blank" rel="nofollow noopener noreferrer">PullMessageProcessor#processRequest(…) 第 64 至 110 行代码</a>。</li>
                <li>第 226 行 ：是否开启过滤类过滤模式。详细解析见：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Ffiltersrv%2F" target="_blank" rel="nofollow noopener noreferrer">《RocketMQ 源码分析 —— Filtersrv》</a>。</li>
                <li>第 229 至 235 行 ：计算拉取消息请求系统标识。详细解析见：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-first%2F%23PullMessageRequestHeader" target="_blank" rel="nofollow noopener noreferrer">PullMessageRequestHeader.sysFlag</a>。</li>
                <li>第 237 至 255 行 ：
                    <ul>
                        <li>执行消息拉取<strong>异步</strong>请求。详细解析见：<a href="#pullapiwrapperpullkernelimpl">PullAPIWrapper#pullKernelImpl(…)</a>。</li>
                        <li>当发起请求产生异常时，提交<strong>延迟</strong>拉取消息请求。对应 <code>Broker</code> 处理拉取消息逻辑见：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage-pull-and-consume-first%2F%23PullMessageProcessor-processRequest-%E2%80%A6" target="_blank" rel="nofollow noopener noreferrer">PullMessageProcessor#processRequest(…)</a>。</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><code>PullCallback</code> ：拉取消息回调：
            <ul>
                <li>第 86 行 ：处理拉取结果。详细逻辑见：<a href="#pullapiwrapperprocesspullresult">PullAPIWrapper#processPullResult(…)</a>。</li>
                <li>第 89 至 192 行 ：处理拉取状态结果：
                    <ul>
                        <li>第 90 至 139 行 ：拉取到消息( <code>FOUND</code> ) ：
                            <ul>
                                <li>第 91 至 93 行 ：设置下次拉取消息队列位置。</li>
                                <li>第 95 至 97 行 ：统计。</li>
                                <li>第 101 至 102 行 ：拉取到消息的消息列表为空，提交<strong>立即</strong>拉取消息请求。为什么会存在拉取到消息，但是消息结果未空呢？原因见：<a href="#pullapiwrapperprocesspullresult">PullAPIWrapper#processPullResult(…)</a>。</li>
                                <li>第 106 至 108 行 ：统计。</li>
                                <li>第 111 行 ：提交拉取到的消息到消息处理队列。详细解析见：<a href="#processqueueputmessage">ProcessQueue#putMessage(…)</a>。</li>
                                <li>第 113 至 118 行 ：提交消费请求到 <code>ConsumeMessageService</code>。详细解析见：<a href="#consumemessageconcurrentlyservice">ConsumeMessageConcurrentlyService</a>。</li>
                                <li>第 120 至 126 行 ：根据拉取频率( <code>pullInterval</code> )，提交<strong>立即或者延迟</strong>拉取消息请求。默认拉取频率为 0ms ，提交<strong>立即</strong>拉取消息请求。</li>
                                <li>第 129 至 137 行 ：下次拉取消息队列位置小于上次拉取消息队列位置 或者 第一条消息的消息队列位置小于上次拉取消息队列位置，则判定为<strong>BUG</strong>，输出警告日志。
                                    <ul>
                                        <li>第 140 至 149 行 ：没有新消息( <code>NO_NEW_MSG</code> ) ：</li>
                                    </ul>
                                </li>
                                <li>第 142 行 ： 设置下次拉取消息队列位置。</li>
                                <li>第 145 行 ：更正消费进度。详细解析见：<code>#correctTagsOffset(...)</code>。</li>
                                <li>第 148 行 ：提交<strong>立即</strong>拉取消息请求。
                                    <ul>
                                        <li>第 150 至 159 行 ：有新消息但是不匹配( <code>NO_MATCHED_MSG</code> )。逻辑同 <code>NO_NEW_MSG</code> 。</li>
                                        <li>第 160 至 189 行 ：拉取请求的消息队列位置不合法 (<code>OFFSET_ILLEGAL</code>)。</li>
                                    </ul>
                                </li>
                                <li>第 164 行 ：设置下次拉取消息队列位置。</li>
                                <li>第 167 行 ：设置消息处理队列为 <code>dropped</code>。</li>
                                <li>第 169 至 188 行 ：提交延迟任务，进行队列移除。
                                    <ul>
                                        <li>第 175 至 178 行 ：更新消费进度，同步消费进度到 <code>Broker</code>。</li>
                                        <li>第 181 行 ：移除消费处理队列。
                                            <ul>
                                                <li>疑问：为什么不立即移除？？？
                                                    <ul>
                                                        <li>第 196 至 204 行 ：发生异常，提交<strong>延迟</strong>拉取消息请求。</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><code>#correctTagsOffset(...)</code> ：更正消费进度。
            <ul>
                <li>第 258 至 261 行 ： 当消费处理队列持有消息数量为 <strong>0</strong> 时，更新消费进度为拉取请求的拉取消息队列位置。</li>
            </ul>
        </li>
    </ul>
    <h3 id="PullAPIWrapper-pullKernelImpl-…" data-id="heading-29"><a href="#PullAPIWrapper-pullKernelImpl-…" title="PullAPIWrapper#pullKernelImpl(…)"></a>PullAPIWrapper#pullKernelImpl(…)</h3>
    <pre><code> 1: /**
 2:  * 拉取消息核心方法
 3:  *
 4:  * @param mq 消息队列
 5:  * @param subExpression 订阅表达式
 6:  * @param subVersion 订阅版本号
 7:  * @param offset 拉取队列开始位置
 8:  * @param maxNums 拉取消息数量
 9:  * @param sysFlag 拉取请求系统标识
10:  * @param commitOffset 提交消费进度
11:  * @param brokerSuspendMaxTimeMillis broker挂起请求最大时间
12:  * @param timeoutMillis 请求broker超时时长
13:  * @param communicationMode 通讯模式
14:  * @param pullCallback 拉取回调
15:  * @return 拉取消息结果。只有通讯模式为同步时，才返回结果，否则返回null。
16:  * @throws MQClientException 当寻找不到 broker 时，或发生其他client异常
17:  * @throws RemotingException 当远程调用发生异常时
18:  * @throws MQBrokerException 当 broker 发生异常时。只有通讯模式为同步时才会发生该异常。
19:  * @throws InterruptedException 当发生中断异常时
20:  */
21: protected PullResult pullKernelImpl(
22:     final MessageQueue mq,
23:     final String subExpression,
24:     final long subVersion,
25:     final long offset,
26:     final int maxNums,
27:     final int sysFlag,
28:     final long commitOffset,
29:     final long brokerSuspendMaxTimeMillis,
30:     final long timeoutMillis,
31:     final CommunicationMode communicationMode,
32:     final PullCallback pullCallback
33: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
34:     // 获取Broker信息
35:     FindBrokerResult findBrokerResult =
36:         this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),
37:             this.recalculatePullFromWhichNode(mq), false);
38:     if (null == findBrokerResult) {
39:         this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());
40:         findBrokerResult =
41:             this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),
42:                 this.recalculatePullFromWhichNode(mq), false);
43:     }
44: 
45:     // 请求拉取消息
46:     if (findBrokerResult != null) {
47:         int sysFlagInner = sysFlag;
48: 
49:         if (findBrokerResult.isSlave()) {
50:             sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);
51:         }
52: 
53:         PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();
54:         requestHeader.setConsumerGroup(this.consumerGroup);
55:         requestHeader.setTopic(mq.getTopic());
56:         requestHeader.setQueueId(mq.getQueueId());
57:         requestHeader.setQueueOffset(offset);
58:         requestHeader.setMaxMsgNums(maxNums);
59:         requestHeader.setSysFlag(sysFlagInner);
60:         requestHeader.setCommitOffset(commitOffset);
61:         requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);
62:         requestHeader.setSubscription(subExpression);
63:         requestHeader.setSubVersion(subVersion);
64: 
65:         String brokerAddr = findBrokerResult.getBrokerAddr();
66:         if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) { // TODO filtersrv
67:             brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);
68:         }
69: 
70:         PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage(
71:             brokerAddr,
72:             requestHeader,
73:             timeoutMillis,
74:             communicationMode,
75:             pullCallback);
76: 
77:         return pullResult;
78:     }
79: 
80:     // Broker信息不存在，则抛出异常
81:     throw new MQClientException("The broker[" + mq.getBrokerName() + "] not exist", null);
82: }
</code></pre>
    <ul>
        <li>说明 ：拉取消息核心方法。<strong>该方法参数较多，可以看下代码注释上每个参数的说明</strong>😈。</li>
        <li>第 34 至 43 行 ：获取 <code>Broker</code> 信息(<code>Broker</code> 地址、是否为从节点)。
            <ul>
                <li><a href="#pullapiwrapperrecalculatepullfromwhichnode">#recalculatePullFromWhichNode(…)</a></li>
                <li><a href="#mqclientinstancefindbrokeraddressinsubscribe">#MQClientInstance#findBrokerAddressInSubscribe(…)</a></li>
            </ul>
        </li>
        <li>第 45 至 78 行 ：<strong>请求拉取消息</strong>。</li>
        <li>第 81 行 ：当 <code>Broker</code> 信息不存在，则抛出异常。</li>
    </ul>
    <h4 id="PullAPIWrapper-recalculatePullFromWhichNode-…" data-id="heading-30"><a href="#PullAPIWrapper-recalculatePullFromWhichNode-…" title="PullAPIWrapper#recalculatePullFromWhichNode(…)"></a>PullAPIWrapper#recalculatePullFromWhichNode(…)</h4>
    <pre><code> 1: /**
 2:  * 消息队列 与 拉取Broker 的映射
 3:  * 当拉取消息时，会通过该映射获取拉取请求对应的Broker
 4:  */
 5: private ConcurrentHashMap&lt;MessageQueue, AtomicLong/* brokerId */&gt; pullFromWhichNodeTable =
 6:     new ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt;(32);
 7: /**
 8:  * 是否使用默认Broker
 9:  */
10: private volatile boolean connectBrokerByUser = false;
11: /**
12:  * 默认Broker编号
13:  */
14: private volatile long defaultBrokerId = MixAll.MASTER_ID;
15: 
16: /**
17:  * 计算消息队列拉取消息对应的Broker编号
18:  *
19:  * @param mq 消息队列
20:  * @return Broker编号
21:  */
22: public long recalculatePullFromWhichNode(final MessageQueue mq) {
23:     // 若开启默认Broker开关，则返回默认Broker编号
24:     if (this.isConnectBrokerByUser()) {
25:         return this.defaultBrokerId;
26:     }
27: 
28:     // 若消息队列映射拉取Broker存在，则返回映射Broker编号
29:     AtomicLong suggest = this.pullFromWhichNodeTable.get(mq);
30:     if (suggest != null) {
31:         return suggest.get();
32:     }
33: 
34:     // 返回Broker主节点编号
35:     return MixAll.MASTER_ID;
36: }
</code></pre>
    <ul>
        <li>说明 ：计算消息队列拉取消息对应的 <code>Broker</code> 编号。</li>
    </ul>
    <h4 id="MQClientInstance-findBrokerAddressInSubscribe-…" data-id="heading-31"><a href="#MQClientInstance-findBrokerAddressInSubscribe-…" title="MQClientInstance#findBrokerAddressInSubscribe(…)"></a>MQClientInstance#findBrokerAddressInSubscribe(…)</h4>
    <pre><code> 1: /**
 2:  * Broker名字 和 Broker地址相关 Map
 3:  */
 4: private final ConcurrentHashMap&lt;String/* Broker Name */, HashMap&lt;Long/* brokerId */, String/* address */&gt;&gt; brokerAddrTable =
 5:         new ConcurrentHashMap&lt;&gt;();
 6: 
 7: /**
 8:  * 获得Broker信息
 9:  *
10:  * @param brokerName broker名字
11:  * @param brokerId broker编号
12:  * @param onlyThisBroker 是否必须是该broker
13:  * @return Broker信息
14:  */
15: public FindBrokerResult findBrokerAddressInSubscribe(//
16:     final String brokerName, //
17:     final long brokerId, //
18:     final boolean onlyThisBroker//
19: ) {
20:     String brokerAddr = null; // broker地址
21:     boolean slave = false; // 是否为从节点
22:     boolean found = false; // 是否找到
23: 
24:     // 获得Broker信息
25:     HashMap&lt;Long/* brokerId */, String/* address */&gt; map = this.brokerAddrTable.get(brokerName);
26:     if (map != null &amp;&amp; !map.isEmpty()) {
27:         brokerAddr = map.get(brokerId);
28:         slave = brokerId != MixAll.MASTER_ID;
29:         found = brokerAddr != null;
30: 
31:         // 如果不强制获得，选择一个Broker
32:         if (!found &amp;&amp; !onlyThisBroker) {
33:             Entry&lt;Long, String&gt; entry = map.entrySet().iterator().next();
34:             brokerAddr = entry.getValue();
35:             slave = entry.getKey() != MixAll.MASTER_ID;
36:             found = true;
37:         }
38:     }
39: 
40:     // 找到broker，则返回信息
41:     if (found) {
42:         return new FindBrokerResult(brokerAddr, slave);
43:     }
44: 
45:     // 找不到，则返回空
46:     return null;
47: }
</code></pre>
    <ul>
        <li>说明 ：获取 <code>Broker</code> 信息(<code>Broker</code> 地址、是否为从节点)。</li>
    </ul>
    <h3 id="PullAPIWrapper-processPullResult-…" data-id="heading-32"><a href="#PullAPIWrapper-processPullResult-…" title="PullAPIWrapper#processPullResult(…)"></a>PullAPIWrapper#processPullResult(…)</h3>
    <pre><code> 1: /**
 2:  * 处理拉取结果
 3:  * 1. 更新消息队列拉取消息Broker编号的映射
 4:  * 2. 解析消息，并根据订阅信息消息tagCode匹配合适消息
 5:  *
 6:  * @param mq 消息队列
 7:  * @param pullResult 拉取结果
 8:  * @param subscriptionData 订阅信息
 9:  * @return 拉取结果
10:  */
11: public PullResult processPullResult(final MessageQueue mq, final PullResult pullResult,
12:     final SubscriptionData subscriptionData) {
13:     PullResultExt pullResultExt = (PullResultExt) pullResult;
14: 
15:     // 更新消息队列拉取消息Broker编号的映射
16:     this.updatePullFromWhichNode(mq, pullResultExt.getSuggestWhichBrokerId());
17: 
18:     // 解析消息，并根据订阅信息消息tagCode匹配合适消息
19:     if (PullStatus.FOUND == pullResult.getPullStatus()) {
20:         // 解析消息
21:         ByteBuffer byteBuffer = ByteBuffer.wrap(pullResultExt.getMessageBinary());
22:         List&lt;MessageExt&gt; msgList = MessageDecoder.decodes(byteBuffer);
23: 
24:         // 根据订阅信息消息tagCode匹配合适消息
25:         List&lt;MessageExt&gt; msgListFilterAgain = msgList;
26:         if (!subscriptionData.getTagsSet().isEmpty() &amp;&amp; !subscriptionData.isClassFilterMode()) {
27:             msgListFilterAgain = new ArrayList&lt;&gt;(msgList.size());
28:             for (MessageExt msg : msgList) {
29:                 if (msg.getTags() != null) {
30:                     if (subscriptionData.getTagsSet().contains(msg.getTags())) {
31:                         msgListFilterAgain.add(msg);
32:                     }
33:                 }
34:             }
35:         }
36: 
37:         // Hook
38:         if (this.hasHook()) {
39:             FilterMessageContext filterMessageContext = new FilterMessageContext();
40:             filterMessageContext.setUnitMode(unitMode);
41:             filterMessageContext.setMsgList(msgListFilterAgain);
42:             this.executeHook(filterMessageContext);
43:         }
44: 
45:         // 设置消息队列当前最小/最大位置到消息拓展字段
46:         for (MessageExt msg : msgListFilterAgain) {
47:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MIN_OFFSET,
48:                 Long.toString(pullResult.getMinOffset()));
49:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MAX_OFFSET,
50:                 Long.toString(pullResult.getMaxOffset()));
51:         }
52: 
53:         // 设置消息列表
54:         pullResultExt.setMsgFoundList(msgListFilterAgain);
55:     }
56: 
57:     // 清空消息二进制数组
58:     pullResultExt.setMessageBinary(null);
59: 
60:     return pullResult;
61: }
</code></pre>
    <ul>
        <li>说明 ：处理拉取结果。
            <ul>
                <li>更新消息队列拉取消息 <code>Broker</code> 编号的映射。</li>
                <li>解析消息，并根据订阅信息消息 <code>tagCode</code>匹配合适消息。</li>
            </ul>
        </li>
        <li>第 16 行 ：更新消息队列拉取消息 <code>Broker</code> 编号的映射。下次拉取消息时，如果未设置默认拉取的 <code>Broker</code> 编号，会使用更新后的 <code>Broker</code> 编号。</li>
        <li>第 18 至 55 行 ：解析消息，并根据订阅信息消息 <code>tagCode</code> 匹配合适消息。
            <ul>
                <li>第 20 至 22 行 ：解析消息。详细解析见：<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.iocoder.cn%2FRocketMQ%2Fmessage%2F" target="_blank" rel="nofollow noopener noreferrer">《RocketMQ 源码分析 —— Message基础》</a> 。</li>
                <li>第 24 至 35 行 ：根据订阅信息<code>tagCode</code> 匹配消息。</li>
                <li>第 37 至 43 行 ：<code>Hook</code>。</li>
                <li>第 45 至 51 行 ：设置消息队列当前最小/最大位置到消息拓展字段。</li>
                <li>第 54 行 ：设置消息队列。</li>
            </ul>
        </li>
        <li>第 58 行 ：清空消息二进制数组。</li>
    </ul>
    <h3 id="ProcessQueue-putMessage-…" data-id="heading-33"><a href="#ProcessQueue-putMessage-…" title="ProcessQueue#putMessage(…)"></a>ProcessQueue#putMessage(…)</h3>
    <pre><code> 1:  /**
 2:  * 消息映射读写锁
 3:  */
 4: private final ReadWriteLock lockTreeMap = new ReentrantReadWriteLock();
 5: /**
 6:  * 消息映射
 7:  * key：消息队列位置
 8:  */
 9: private final TreeMap&lt;Long, MessageExt&gt; msgTreeMap = new TreeMap&lt;&gt;();
10: /**
11:  * 消息数
12:  */
13: private final AtomicLong msgCount = new AtomicLong();
14: /**
15:  * 添加消息最大队列位置
16:  */
17: private volatile long queueOffsetMax = 0L;
18: /**
19:  * 是否正在消费
20:  */
21: private volatile boolean consuming = false;
22: /**
23:  * Broker累计消息数量
24:  * 计算公式 = queueMaxOffset - 新添加消息数组[n - 1].queueOffset
25:  * Acc = Accumulation
26:  * cnt = （猜测）对比度
27:  */
28: private volatile long msgAccCnt = 0;
29: 
30: /**
31:  * 添加消息，并返回是否提交给消费者
32:  * 返回true，当有新消息添加成功时，
33:  *
34:  * @param msgs 消息
35:  * @return 是否提交给消费者
36:  */
37: public boolean putMessage(final List&lt;MessageExt&gt; msgs) {
38:     boolean dispatchToConsume = false;
39:     try {
40:         this.lockTreeMap.writeLock().lockInterruptibly();
41:         try {
42:             // 添加消息
43:             int validMsgCnt = 0;
44:             for (MessageExt msg : msgs) {
45:                 MessageExt old = msgTreeMap.put(msg.getQueueOffset(), msg);
46:                 if (null == old) {
47:                     validMsgCnt++;
48:                     this.queueOffsetMax = msg.getQueueOffset();
49:                 }
50:             }
51:             msgCount.addAndGet(validMsgCnt);
52: 
53:             // 计算是否正在消费
54:             if (!msgTreeMap.isEmpty() &amp;&amp; !this.consuming) {
55:                 dispatchToConsume = true;
56:                 this.consuming = true;
57:             }
58: 
59:             // Broker累计消息数量
60:             if (!msgs.isEmpty()) {
61:                 MessageExt messageExt = msgs.get(msgs.size() - 1);
62:                 String property = messageExt.getProperty(MessageConst.PROPERTY_MAX_OFFSET);
63:                 if (property != null) {
64:                     long accTotal = Long.parseLong(property) - messageExt.getQueueOffset();
65:                     if (accTotal &gt; 0) {
66:                         this.msgAccCnt = accTotal;
67:                     }
68:                 }
69:             }
70:         } finally {
71:             this.lockTreeMap.writeLock().unlock();
72:         }
73:     } catch (InterruptedException e) {
74:         log.error("putMessage exception", e);
75:     }
76: 
77:     return dispatchToConsume;
78: }
</code></pre>
    <h2 id="总结" data-id="heading-34"><a href="#总结" title="总结"></a>总结</h2>
    <p>如果用最简单粗暴的方式描述 <code>PullConsumer</code> 拉取消息的过程，那就是如下的代码：</p>
    <pre><code>while (true) {
    if (不满足拉取消息) {
        Thread.sleep(间隔);
        continue;
    }
    主动拉取消息();
}
</code></pre>
    <h1 id="6、PushConsumer-消费消息" data-id="heading-35"><a href="#6、PushConsumer-消费消息" title="6、PushConsumer 消费消息"></a>6、PushConsumer 消费消息</h1>
    <p><img alt="DefaultMQPushConsumerImpl消费消息" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/10/21/166937eb32b5a834?imageView2/0/w/1280/h/960/ignore-error/1" data-width="1280" data-height="680" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;680&quot;&gt;&lt;/svg&gt;"></p>
    <h2 id="ConsumeMessageConcurrentlyService-提交消费请求" data-id="heading-36"><a href="#ConsumeMessageConcurrentlyService-提交消费请求" title="ConsumeMessageConcurrentlyService 提交消费请求"></a>ConsumeMessageConcurrentlyService 提交消费请求</h2>
    <h3 id="ConsumeMessageConcurrentlyService-submitConsumeRequest-…" data-id="heading-37"><a href="#ConsumeMessageConcurrentlyService-submitConsumeRequest-…" title="ConsumeMessageConcurrentlyService#submitConsumeRequest(…)"></a>ConsumeMessageConcurrentlyService#submitConsumeRequest(…)</h3>
    <pre><code> 1: /**
 2:  * 消费线程池队列
 3:  */
 4: private final BlockingQueue&lt;Runnable&gt; consumeRequestQueue;
 5: /**
 6:  * 消费线程池
 7:  */
 8: private final ThreadPoolExecutor consumeExecutor;
 9: 
10: public void submitConsumeRequest(//
11:     final List&lt;MessageExt&gt; msgs, //
12:     final ProcessQueue processQueue, //
13:     final MessageQueue messageQueue, //
14:     final boolean dispatchToConsume) {
15:     final int consumeBatchSize = this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();
16:     if (msgs.size() &lt;= consumeBatchSize) { // 提交消息小于批量消息数，直接提交消费请求
17:         ConsumeRequest consumeRequest = new ConsumeRequest(msgs, processQueue, messageQueue);
18:         try {
19:             this.consumeExecutor.submit(consumeRequest);
20:         } catch (RejectedExecutionException e) {
21:             this.submitConsumeRequestLater(consumeRequest);
22:         }
23:     } else { // 提交消息大于批量消息数，进行分拆成多个消费请求
24:         for (int total = 0; total &lt; msgs.size(); ) {
25:             // 计算当前拆分请求包含的消息
26:             List&lt;MessageExt&gt; msgThis = new ArrayList&lt;&gt;(consumeBatchSize);
27:             for (int i = 0; i &lt; consumeBatchSize; i++, total++) {
28:                 if (total &lt; msgs.size()) {
29:                     msgThis.add(msgs.get(total));
30:                 } else {
31:                     break;
32:                 }
33:             }
34: 
35:             // 提交拆分消费请求
36:             ConsumeRequest consumeRequest = new ConsumeRequest(msgThis, processQueue, messageQueue);
37:             try {
38:                 this.consumeExecutor.submit(consumeRequest);
39:             } catch (RejectedExecutionException e) {
40:                 // 如果被拒绝，则将当前拆分消息+剩余消息提交延迟消费请求。
41:                 for (; total &lt; msgs.size(); total++) {
42:                     msgThis.add(msgs.get(total));
43:                 }
44:                 this.submitConsumeRequestLater(consumeRequest);
45:             }
46:         }
47:     }
48: }
</code></pre>
    <ul>
        <li>说明 ：提交<strong>立即</strong>消费请求。</li>
        <li>第 16 至 22 行 ：提交消息小于等于批量消费数，直接提交消费请求。</li>
        <li>第 23 至 47 行 ：当提交消息大于批量消费数，进行分拆成多个请求。
            <ul>
                <li>第 25 至 33 行 ：计算当前拆分请求包含的消息。</li>
                <li>第 35 至 38 行 ：提交拆分消费请求。</li>
                <li>第 39 至 44 行 ：提交请求被拒绝，则将当前拆分消息 + 剩余消息提交延迟消费请求，结束拆分循环。</li>
            </ul>
        </li>
    </ul>
    <h3 id="ConsumeMessageConcurrentlyService-submitConsumeRequestLater" data-id="heading-38"><a href="#ConsumeMessageConcurrentlyService-submitConsumeRequestLater" title="ConsumeMessageConcurrentlyService#submitConsumeRequestLater"></a>ConsumeMessageConcurrentlyService#submitConsumeRequestLater</h3>
    <pre><code>  1: /**
 2:  * 提交延迟消费请求
 3:  *
 4:  * @param msgs 消息列表
 5:  * @param processQueue 消息处理队列
 6:  * @param messageQueue 消息队列
 7:  */
 8: private void submitConsumeRequestLater(//
 9:     final List&lt;MessageExt&gt; msgs, //
10:     final ProcessQueue processQueue, //
11:     final MessageQueue messageQueue//
12: ) {
13: 
14:     this.scheduledExecutorService.schedule(new Runnable() {
15: 
16:         @Override
17:         public void run() {
18:             ConsumeMessageConcurrentlyService.this.submitConsumeRequest(msgs, processQueue, messageQueue, true);
19:         }
20:     }, 5000, TimeUnit.MILLISECONDS);
21: }
22: 
23: /**
24:  * 提交延迟消费请求
25:  * @param consumeRequest 消费请求
26:  */
27: private void submitConsumeRequestLater(final ConsumeRequest consumeRequest//
28: ) {
29: 
30:     this.scheduledExecutorService.schedule(new Runnable() {
31: 
32:         @Override
33:         public void run() {
34:             ConsumeMessageConcurrentlyService.this.consumeExecutor.submit(consumeRequest); // TODO BUG ?
35:         }
36:     }, 5000, TimeUnit.MILLISECONDS);
37: }
</code></pre>
    <ul>
        <li>说明 ：提交延迟消费请求。</li>
        <li>第 34 行 ：直接调用 <code>ConsumeMessageConcurrentlyService.this.consumeExecutor.submit(consumeRequest);</code>。如果消息数超过批量消费上限，会不会是<strong>BUG</strong>。</li>
    </ul>
    <h2 id="ConsumeRequest" data-id="heading-39"><a href="#ConsumeRequest" title="ConsumeRequest"></a>ConsumeRequest</h2>
    <pre><code>  1: class ConsumeRequest implements Runnable {
  2: 
  3:     /**
  4:      * 消费消息列表
  5:      */
  6:     private final List&lt;MessageExt&gt; msgs;
  7:     /**
  8:      * 消息处理队列
  9:      */
 10:     private final ProcessQueue processQueue;
 11:     /**
 12:      * 消息队列
 13:      */
 14:     private final MessageQueue messageQueue;
 15: 
 16:     public ConsumeRequest(List&lt;MessageExt&gt; msgs, ProcessQueue processQueue, MessageQueue messageQueue) {
 17:         this.msgs = msgs;
 18:         this.processQueue = processQueue;
 19:         this.messageQueue = messageQueue;
 20:     }
 21: 
 22:     @Override
 23:     public void run() {
 24:         // 废弃队列不进行消费
 25:         if (this.processQueue.isDropped()) {
 26:             log.info("the message queue not be able to consume, because it's dropped. group={} {}", ConsumeMessageConcurrentlyService.this.consumerGroup, this.messageQueue);
 27:             return;
 28:         }
 29: 
 30:         MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.this.messageListener; // 监听器
 31:         ConsumeConcurrentlyContext context = new ConsumeConcurrentlyContext(messageQueue); // 消费Context
 32:         ConsumeConcurrentlyStatus status = null; // 消费结果状态
 33: 
 34:         // Hook
 35:         ConsumeMessageContext consumeMessageContext = null;
 36:         if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
 37:             consumeMessageContext = new ConsumeMessageContext();
 38:             consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());
 39:             consumeMessageContext.setProps(new HashMap&lt;String, String&gt;());
 40:             consumeMessageContext.setMq(messageQueue);
 41:             consumeMessageContext.setMsgList(msgs);
 42:             consumeMessageContext.setSuccess(false);
 43:             ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);
 44:         }
 45: 
 46:         long beginTimestamp = System.currentTimeMillis();
 47:         boolean hasException = false;
 48:         ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; // 消费返回结果类型
 49:         try {
 50:             // 当消息为重试消息，设置Topic为原始Topic
 51:             ConsumeMessageConcurrentlyService.this.resetRetryTopic(msgs);
 52: 
 53:             // 设置开始消费时间
 54:             if (msgs != null &amp;&amp; !msgs.isEmpty()) {
 55:                 for (MessageExt msg : msgs) {
 56:                     MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));
 57:                 }
 58:             }
 59: 
 60:             // 进行消费
 61:             status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);
 62:         } catch (Throwable e) {
 63:             log.warn("consumeMessage exception: {} Group: {} Msgs: {} MQ: {}",
 64:                 RemotingHelper.exceptionSimpleDesc(e), //
 65:                 ConsumeMessageConcurrentlyService.this.consumerGroup,
 66:                 msgs,
 67:                 messageQueue);
 68:             hasException = true;
 69:         }
 70: 
 71:         // 解析消费返回结果类型
 72:         long consumeRT = System.currentTimeMillis() - beginTimestamp;
 73:         if (null == status) {
 74:             if (hasException) {
 75:                 returnType = ConsumeReturnType.EXCEPTION;
 76:             } else {
 77:                 returnType = ConsumeReturnType.RETURNNULL;
 78:             }
 79:         } else if (consumeRT &gt;= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {
 80:             returnType = ConsumeReturnType.TIME_OUT;
 81:         } else if (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) {
 82:             returnType = ConsumeReturnType.FAILED;
 83:         } else if (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) {
 84:             returnType = ConsumeReturnType.SUCCESS;
 85:         }
 86: 
 87:         // Hook
 88:         if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
 89:             consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());
 90:         }
 91: 
 92:         // 消费结果状态为空时，则设置为稍后重新消费
 93:         if (null == status) {
 94:             log.warn("consumeMessage return null, Group: {} Msgs: {} MQ: {}",
 95:                 ConsumeMessageConcurrentlyService.this.consumerGroup,
 96:                 msgs,
 97:                 messageQueue);
 98:             status = ConsumeConcurrentlyStatus.RECONSUME_LATER;
 99:         }
100: 
101:         // Hook
102:         if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {
103:             consumeMessageContext.setStatus(status.toString());
104:             consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);
105:             ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);
106:         }
107: 
108:         // 统计
109:         ConsumeMessageConcurrentlyService.this.getConsumerStatsManager()
110:             .incConsumeRT(ConsumeMessageConcurrentlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);
111: 
112:         // 处理消费结果
113:         if (!processQueue.isDropped()) {
114:             ConsumeMessageConcurrentlyService.this.processConsumeResult(status, context, this);
115:         } else {
116:             log.warn("processQueue is dropped without process consume result. messageQueue={}, msgs={}", messageQueue, msgs);
117:         }
118:     }
119: 
120: }
</code></pre>
    <ul>
        <li>说明 ：消费请求。提交请求执行消费。</li>
        <li>第 24 至 28 行 ：废弃处理队列不进行消费。</li>
        <li>第 34 至 44 行 ：Hook。</li>
        <li>第 51 行 ：当消息为重试消息，设置 <code>Topic</code>为原始 <code>Topic</code>。例如：原始 <code>Topic</code> 为 <code>TopicTest</code>，重试时 <code>Topic</code> 为 <code>%RETRY%please_rename_unique_group_name_4</code>，经过该方法，<code>Topic</code> 设置回 <code>TopicTest</code>。</li>
        <li>第 53 至 58 行 ：设置开始消费时间。</li>
        <li>第 61 行 ：<strong>进行消费</strong>。</li>
        <li>第 71 至 85 行 ：解析消费返回结果类型</li>
        <li>第 87 至 90 行 ：<code>Hook</code>。</li>
        <li>第 92 至 99 行 ：消费结果状态未空时，则设置消费结果状态为稍后消费。</li>
        <li>第 101 至 106 行 ：<code>Hook</code>。</li>
        <li>第 108 至 110 行 ：统计。</li>
        <li>第 112 至 117 行 ：处理消费结果。<strong>如果消费处理队列被移除，恰好消息被消费，则可能导致消息重复消费，因此，消息消费要尽最大可能性实现幂等性</strong>。详细解析见：<a href="#consumemessageconcurrentlyserviceprocessconsumeresult">ConsumeMessageConcurrentlyService#processConsumeResult(…)</a>。</li>
    </ul>
    <h2 id="ConsumeMessageConcurrentlyService-processConsumeResult-…" data-id="heading-40"><a href="#ConsumeMessageConcurrentlyService-processConsumeResult-…" title="ConsumeMessageConcurrentlyService#processConsumeResult(…)"></a>ConsumeMessageConcurrentlyService#processConsumeResult(…)</h2>
    <pre><code> 1: public void processConsumeResult(//
 2:     final ConsumeConcurrentlyStatus status, //
 3:     final ConsumeConcurrentlyContext context, //
 4:     final ConsumeRequest consumeRequest//
 5: ) {
 6:     int ackIndex = context.getAckIndex();
 7: 
 8:     // 消息为空，直接返回
 9:     if (consumeRequest.getMsgs().isEmpty())
10:         return;
11: 
12:     // 计算从consumeRequest.msgs[0]到consumeRequest.msgs[ackIndex]的消息消费成功
13:     switch (status) {
14:         case CONSUME_SUCCESS:
15:             if (ackIndex &gt;= consumeRequest.getMsgs().size()) {
16:                 ackIndex = consumeRequest.getMsgs().size() - 1;
17:             }
18:             // 统计成功/失败数量
19:             int ok = ackIndex + 1;
20:             int failed = consumeRequest.getMsgs().size() - ok;
21:             this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);
22:             this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);
23:             break;
24:         case RECONSUME_LATER:
25:             ackIndex = -1;
26:             // 统计成功/失败数量
27:             this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),
28:                 consumeRequest.getMsgs().size());
29:             break;
30:         default:
31:             break;
32:     }
33: 
34:     // 处理消费失败的消息
35:     switch (this.defaultMQPushConsumer.getMessageModel()) {
36:         case BROADCASTING: // 广播模式，无论是否消费失败，不发回消息到Broker，只打印Log
37:             for (int i = ackIndex + 1; i &lt; consumeRequest.getMsgs().size(); i++) {
38:                 MessageExt msg = consumeRequest.getMsgs().get(i);
39:                 log.warn("BROADCASTING, the message consume failed, drop it, {}", msg.toString());
40:             }
41:             break;
42:         case CLUSTERING:
43:             // 发回消息失败到Broker。
44:             List&lt;MessageExt&gt; msgBackFailed = new ArrayList&lt;&gt;(consumeRequest.getMsgs().size());
45:             for (int i = ackIndex + 1; i &lt; consumeRequest.getMsgs().size(); i++) {
46:                 MessageExt msg = consumeRequest.getMsgs().get(i);
47:                 boolean result = this.sendMessageBack(msg, context);
48:                 if (!result) {
49:                     msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
50:                     msgBackFailed.add(msg);
51:                 }
52:             }
53: 
54:             // 发回Broker失败的消息，直接提交延迟重新消费
55:             if (!msgBackFailed.isEmpty()) {
56:                 consumeRequest.getMsgs().removeAll(msgBackFailed);
57: 
58:                 this.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());
59:             }
60:             break;
61:         default:
62:             break;
63:     }
64: 
65:     // 移除消费成功消息，并更新最新消费进度
66:     long offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());
67:     if (offset &gt;= 0 &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) {
68:         this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, true);
69:     }
70: }
</code></pre>
    <ul>
        <li>说明 ：处理消费结果。</li>
        <li>第 8 至 10 行 ：消费请求消息未空时，直接返回。</li>
        <li>第 12 至 32 行 ：计算 <code>ackIndex</code> 值。<code>consumeRequest.msgs[0 - ackIndex]</code>为消费成功，需要进行 <code>ack</code> 确认。
            <ul>
                <li>第 14 至 23 行 ：<code>CONSUME_SUCCESS</code> ：<code>ackIndex = context.getAckIndex()</code>。</li>
                <li>第 24 至 29 行 ：<code>RECONSUME_LATER</code> ：<code>ackIndex = -1</code>。</li>
            </ul>
        </li>
        <li>第34 至 63 行 ：处理消费失败的消息。
            <ul>
                <li>第 36 至 41 行 ：<code>BROADCASTING</code> ：广播模式，无论是否消费失败，不发回消息到 <code>Broker</code>，只打印日志。</li>
                <li>第 42 至 60 行 ：<code>CLUSTERING</code> ：集群模式，消费失败的消息发回到 <code>Broker</code>。
                    <ul>
                        <li>第 43 至 52 行 ：发回消费失败的消息到 <code>Broker</code>。详细解析见：<a href="#defaultmqpushconsumerimplsendmessageback">DefaultMQPushConsumerImpl#sendMessageBack(…)</a>。</li>
                        <li>第 54 至 59 行 ：发回 <code>Broker</code> 失败的消息，直接提交延迟重新消费。</li>
                        <li>如果发回 <code>Broker</code> 成功，结果因为例如网络异常，导致 <code>Consumer</code>以为发回失败，判定消费发回失败，会导致消息重复消费，因此，消息消费要尽最大可能性实现幂等性。</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>第 65 至 69 行 ：移除<strong>【消费成功】</strong>和【消费失败但发回<code>Broker</code>成功】的消息，并更新最新消费进度。
            <ul>
                <li>为什么会有<strong>【消费失败但发回<code>Broker</code>成功】</strong>的消息？见<strong>第 56 行</strong>。</li>
                <li><a href="#processqueueremovemessage">ProcessQueue#removeMessage(…)</a></li>
            </ul>
        </li>
    </ul>
    <h3 id="ProcessQueue-removeMessage-…" data-id="heading-41"><a href="#ProcessQueue-removeMessage-…" title="ProcessQueue#removeMessage(…)"></a>ProcessQueue#removeMessage(…)</h3>
    <pre><code> 1: /**
 2:  * 移除消息，并返回第一条消息队列位置
 3:  *
 4:  * @param msgs 消息
 5:  * @return 消息队列位置
 6:  */
 7: public long removeMessage(final List&lt;MessageExt&gt; msgs) {
 8:     long result = -1;
 9:     final long now = System.currentTimeMillis();
10:     try {
11:         this.lockTreeMap.writeLock().lockInterruptibly();
12:         this.lastConsumeTimestamp = now;
13:         try {
14:             if (!msgTreeMap.isEmpty()) {
15:                 result = this.queueOffsetMax + 1; // 这里+1的原因是：如果msgTreeMap为空时，下一条获得的消息位置为queueOffsetMax+1
16: 
17:                 // 移除消息
18:                 int removedCnt = 0;
19:                 for (MessageExt msg : msgs) {
20:                     MessageExt prev = msgTreeMap.remove(msg.getQueueOffset());
21:                     if (prev != null) {
22:                         removedCnt--;
23:                     }
24:                 }
25:                 msgCount.addAndGet(removedCnt);
26: 
27:                 if (!msgTreeMap.isEmpty()) {
28:                     result = msgTreeMap.firstKey();
29:                 }
30:             }
31:         } finally {
32:             this.lockTreeMap.writeLock().unlock();
33:         }
34:     } catch (Throwable t) {
35:         log.error("removeMessage exception", t);
36:     }
37: 
38:     return result;
39: }
</code></pre>
    <h2 id="ConsumeMessageConcurrentlyService-cleanExpireMsg-…" data-id="heading-42"><a href="#ConsumeMessageConcurrentlyService-cleanExpireMsg-…" title="ConsumeMessageConcurrentlyService#cleanExpireMsg(…)"></a>ConsumeMessageConcurrentlyService#cleanExpireMsg(…)</h2>
    <pre><code> 1: public void start() {
 2:     this.cleanExpireMsgExecutors.scheduleAtFixedRate(new Runnable() {
 3: 
 4:         @Override
 5:         public void run() {
 6:             cleanExpireMsg();
 7:         }
 8: 
 9:     }, this.defaultMQPushConsumer.getConsumeTimeout(), this.defaultMQPushConsumer.getConsumeTimeout(), TimeUnit.MINUTES);
10: }
11: 
12: /**
13:  * 清理过期消息
14:  */
15: private void cleanExpireMsg() {
16:     Iterator&lt;Map.Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it =
17:         this.defaultMQPushConsumerImpl.getRebalanceImpl().getProcessQueueTable().entrySet().iterator();
18:     while (it.hasNext()) {
19:         Map.Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();
20:         ProcessQueue pq = next.getValue();
21:         pq.cleanExpiredMsg(this.defaultMQPushConsumer);
22:     }
23: }
</code></pre>
    <ul>
        <li>说明 ：定时清理过期消息，默认周期：15min。</li>
    </ul>
    <h3 id="ProcessQueue-cleanExpiredMsg-…" data-id="heading-43"><a href="#ProcessQueue-cleanExpiredMsg-…" title="ProcessQueue#cleanExpiredMsg(…)"></a>ProcessQueue#cleanExpiredMsg(…)</h3>
    <pre><code> 1: public void cleanExpiredMsg(DefaultMQPushConsumer pushConsumer) {
 2:     // 顺序消费时，直接返回
 3:     if (pushConsumer.getDefaultMQPushConsumerImpl().isConsumeOrderly()) {
 4:         return;
 5:     }
 6: 
 7:     // 循环移除消息
 8:     int loop = msgTreeMap.size() &lt; 16 ? msgTreeMap.size() : 16; // 每次循环最多移除16条
 9:     for (int i = 0; i &lt; loop; i++) {
10:         // 获取第一条消息。判断是否超时，若不超时，则结束循环
11:         MessageExt msg = null;
12:         try {
13:             this.lockTreeMap.readLock().lockInterruptibly();
14:             try {
15:                 if (!msgTreeMap.isEmpty() &amp;&amp; System.currentTimeMillis() - Long.parseLong(MessageAccessor.getConsumeStartTimeStamp(msgTreeMap.firstEntry().getValue())) &gt; pushConsumer.getConsumeTimeout() * 60 * 1000) {
16:                     msg = msgTreeMap.firstEntry().getValue();
17:                 } else {
18:                     break;
19:                 }
20:             } finally {
21:                 this.lockTreeMap.readLock().unlock();
22:             }
23:         } catch (InterruptedException e) {
24:             log.error("getExpiredMsg exception", e);
25:         }
26: 
27:         try {
28:             // 发回超时消息
29:             pushConsumer.sendMessageBack(msg, 3);
30:             log.info("send expire msg back. topic={}, msgId={}, storeHost={}, queueId={}, queueOffset={}", msg.getTopic(), msg.getMsgId(), msg.getStoreHost(), msg.getQueueId(), msg.getQueueOffset());
31: 
32:             // 判断此时消息是否依然是第一条，若是，则进行移除
33:             try {
34:                 this.lockTreeMap.writeLock().lockInterruptibly();
35:                 try {
36:                     if (!msgTreeMap.isEmpty() &amp;&amp; msg.getQueueOffset() == msgTreeMap.firstKey()) {
37:                         try {
38:                             msgTreeMap.remove(msgTreeMap.firstKey());
39:                         } catch (Exception e) {
40:                             log.error("send expired msg exception", e);
41:                         }
42:                     }
43:                 } finally {
44:                     this.lockTreeMap.writeLock().unlock();
45:                 }
46:             } catch (InterruptedException e) {
47:                 log.error("getExpiredMsg exception", e);
48:             }
49:         } catch (Exception e) {
50:             log.error("send expired msg exception", e);
51:         }
52:     }
53: }
</code></pre>
    <ul>
        <li>说明 ：移除过期消息。</li>
        <li>第 2 至 5 行 ：顺序消费时，直接返回。</li>
        <li>第 7 至 9 行 ：循环移除消息。默认最大循环次数：16次。</li>
        <li>第 10 至 25 行 ：获取第一条消息。判断是否超时，若不超时，则结束循环。</li>
        <li>第 29 行 ：发回超时消息到<code>Broker</code>。</li>
        <li>第 32 至 48 行 ：判断此时消息是否依然是第一条，若是，则进行移除。</li>
    </ul>
    <h1 id="7、PushConsumer-发回消费失败消息" data-id="heading-44"><a href="#7、PushConsumer-发回消费失败消息" title="7、PushConsumer 发回消费失败消息"></a>7、PushConsumer 发回消费失败消息</h1>
    <h2 id="DefaultMQPushConsumerImpl-sendMessageBack-…" data-id="heading-45"><a href="#DefaultMQPushConsumerImpl-sendMessageBack-…" title="DefaultMQPushConsumerImpl#sendMessageBack(…)"></a>DefaultMQPushConsumerImpl#sendMessageBack(…)</h2>
    <pre><code> 1: public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName)
 2:     throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
 3:     try {
 4:         // Consumer发回消息
 5:         String brokerAddr = (null != brokerName) ? this.mQClientFactory.findBrokerAddressInPublish(brokerName)
 6:             : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());
 7:         this.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,
 8:             this.defaultMQPushConsumer.getConsumerGroup(), delayLevel, 5000, getMaxReconsumeTimes());
 9:     } catch (Exception e) { // TODO 疑问：什么情况下会发生异常
10:         // 异常时，使用Client内置Producer发回消息
11:         log.error("sendMessageBack Exception, " + this.defaultMQPushConsumer.getConsumerGroup(), e);
12: 
13:         Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());
14: 
15:         String originMsgId = MessageAccessor.getOriginMessageId(msg);
16:         MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);
17: 
18:         newMsg.setFlag(msg.getFlag());
19:         MessageAccessor.setProperties(newMsg, msg.getProperties());
20:         MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());
21:         MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + 1));
22:         MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));
23:         newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());
24: 
25:         this.mQClientFactory.getDefaultMQProducer().send(newMsg);
26:     }
27: }
</code></pre>
    <ul>
        <li>说明 ：发回消息。</li>
        <li>第 4 至 8 行 ：<code>Consumer</code> 发回消息。详细解析见：<a href="#mqclientapiimplconsumersendmessageback">MQClientAPIImpl#consumerSendMessageBack(…)</a>。</li>
        <li>第 10 至 25 行 ：发生异常时，<code>Consumer</code> 内置默认 <code>Producer</code> 发送消息。
            <ul>
                <li>😈疑问：什么样的情况下会发生异常呢？</li>
            </ul>
        </li>
    </ul>
    <h3 id="MQClientAPIImpl-consumerSendMessageBack-…" data-id="heading-46"><a href="#MQClientAPIImpl-consumerSendMessageBack-…" title="MQClientAPIImpl#consumerSendMessageBack(…)"></a>MQClientAPIImpl#consumerSendMessageBack(…)</h3>
    <pre><code> 1: /**
 2:  * Consumer发回消息
 3:  * @param addr Broker地址
 4:  * @param msg 消息
 5:  * @param consumerGroup 消费分组
 6:  * @param delayLevel 延迟级别
 7:  * @param timeoutMillis 超时
 8:  * @param maxConsumeRetryTimes 消费最大重试次数
 9:  * @throws RemotingException 当远程调用发生异常时
10:  * @throws MQBrokerException 当Broker发生异常时
11:  * @throws InterruptedException 当线程中断时
12:  */
13: public void consumerSendMessageBack(
14:     final String addr,
15:     final MessageExt msg,
16:     final String consumerGroup,
17:     final int delayLevel,
18:     final long timeoutMillis,
19:     final int maxConsumeRetryTimes
20: ) throws RemotingException, MQBrokerException, InterruptedException {
21:     ConsumerSendMsgBackRequestHeader requestHeader = new ConsumerSendMsgBackRequestHeader();
22:     RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONSUMER_SEND_MSG_BACK, requestHeader);
23: 
24:     requestHeader.setGroup(consumerGroup);
25:     requestHeader.setOriginTopic(msg.getTopic());
26:     requestHeader.setOffset(msg.getCommitLogOffset());
27:     requestHeader.setDelayLevel(delayLevel);
28:     requestHeader.setOriginMsgId(msg.getMsgId());
29:     requestHeader.setMaxReconsumeTimes(maxConsumeRetryTimes);
30: 
31:     RemotingCommand response = this.remotingClient.invokeSync(MixAll.brokerVIPChannel(this.clientConfig.isVipChannelEnabled(), addr),
32:         request, timeoutMillis);
33:     assert response != null;
34:     switch (response.getCode()) {
35:         case ResponseCode.SUCCESS: {
36:             return;
37:         }
38:         default:
39:             break;
40:     }
41: 
42:     throw new MQBrokerException(response.getCode(), response.getRemark());
43: }
</code></pre>
    <h1 id="8、Consumer-消费进度" data-id="heading-47"><a href="#8、Consumer-消费进度" title="8、Consumer 消费进度"></a>8、Consumer 消费进度</h1>
    <h2 id="OffsetStore" data-id="heading-48"><a href="#OffsetStore" title="OffsetStore"></a>OffsetStore</h2>
    <p><img alt="OffsetStore类图.png" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/10/21/166937eb48426e1d?imageView2/0/w/1280/h/960/ignore-error/1" data-width="904" data-height="480" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;904&quot; height=&quot;480&quot;&gt;&lt;/svg&gt;"></p>
    <ul>
        <li><code>RemoteBrokerOffsetStore</code> ：<code>Consumer</code> <strong>集群模式</strong> 下，使用远程 <code>Broker</code> 消费进度。</li>
        <li><code>LocalFileOffsetStore</code> ：<code>Consumer</code> <strong>广播模式</strong>下，使用本地 <code>文件</code> 消费进度。</li>
    </ul>
    <h3 id="OffsetStore-load-…" data-id="heading-49"><a href="#OffsetStore-load-…" title="OffsetStore#load(…)"></a>OffsetStore#load(…)</h3>
    <h4 id="LocalFileOffsetStore-load-…" data-id="heading-50"><a href="#LocalFileOffsetStore-load-…" title="LocalFileOffsetStore#load(…)"></a>LocalFileOffsetStore#load(…)</h4>
    <pre><code> 1: @Override
 2: public void load() throws MQClientException {
 3:     // 从本地硬盘读取消费进度
 4:     OffsetSerializeWrapper offsetSerializeWrapper = this.readLocalOffset();
 5:     if (offsetSerializeWrapper != null &amp;&amp; offsetSerializeWrapper.getOffsetTable() != null) {
 6:         offsetTable.putAll(offsetSerializeWrapper.getOffsetTable());
 7: 
 8:         // 打印每个消息队列的消费进度
 9:         for (MessageQueue mq : offsetSerializeWrapper.getOffsetTable().keySet()) {
10:             AtomicLong offset = offsetSerializeWrapper.getOffsetTable().get(mq);
11:             log.info("load consumer's offset, {} {} {}",
12:                 this.groupName,
13:                 mq,
14:                 offset.get());
15:         }
16:     }
17: }
</code></pre>
    <ul>
        <li>说明 ：从本地文件加载消费进度到内存。</li>
    </ul>
    <h5 id="OffsetSerializeWrapper" data-id="heading-51"><a href="#OffsetSerializeWrapper" title="OffsetSerializeWrapper"></a>OffsetSerializeWrapper</h5>
    <pre><code> 1: public class OffsetSerializeWrapper extends RemotingSerializable {
 2:     private ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt; offsetTable =
 3:             new ConcurrentHashMap&lt;&gt;();
 4: 
 5:     public ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt; getOffsetTable() {
 6:         return offsetTable;
 7:     }
 8: 
 9:     public void setOffsetTable(ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt; offsetTable) {
10:         this.offsetTable = offsetTable;
11:     }
12: }
</code></pre>
    <ul>
        <li>说明 ：本地 <code>Offset</code> 存储序列化。</li>
    </ul>
    <pre><code>Yunai-MacdeMacBook-Pro-2:config yunai$ cat /Users/yunai/.rocketmq_offsets/192.168.17.0@DEFAULT/please_rename_unique_group_name_1/offsets.json
{
	"offsetTable":{{
			"brokerName":"broker-a",
			"queueId":3,
			"topic":"TopicTest"
		}:1470,{
			"brokerName":"broker-a",
			"queueId":2,
			"topic":"TopicTest"
		}:1471,{
			"brokerName":"broker-a",
			"queueId":1,
			"topic":"TopicTest"
		}:1470,{
			"brokerName":"broker-a",
			"queueId":0,
			"topic":"TopicTest"
		}:1470
	}
}
</code></pre>
    <h4 id="RemoteBrokerOffsetStore-load-…" data-id="heading-52"><a href="#RemoteBrokerOffsetStore-load-…" title="RemoteBrokerOffsetStore#load(…)"></a>RemoteBrokerOffsetStore#load(…)</h4>
    <pre><code>1: @Override
2: public void load() {
3: }
</code></pre>
    <ul>
        <li>说明 ：不进行加载，实际读取消费进度时，从 <code>Broker</code> 获取。</li>
    </ul>
    <h3 id="OffsetStore-readOffset-…" data-id="heading-53"><a href="#OffsetStore-readOffset-…" title="OffsetStore#readOffset(…)"></a>OffsetStore#readOffset(…)</h3>
    <p>读取消费进度类型：</p>
    <ul>
        <li><code>READ_FROM_MEMORY</code> ：从内存读取。</li>
        <li><code>READ_FROM_STORE</code> ：从存储( <code>Broker</code> 或 <code>文件</code> )读取。</li>
        <li><code>MEMORY_FIRST_THEN_STORE</code> ：优先从内存读取，读取不到，从存储读取。</li>
    </ul>
    <h4 id="LocalFileOffsetStore-readOffset-…" data-id="heading-54"><a href="#LocalFileOffsetStore-readOffset-…" title="LocalFileOffsetStore#readOffset(…)"></a>LocalFileOffsetStore#readOffset(…)</h4>
    <pre><code> 1: @Override
 2: public long readOffset(final MessageQueue mq, final ReadOffsetType type) {
 3:     if (mq != null) {
 4:         switch (type) {
 5:             case MEMORY_FIRST_THEN_STORE:
 6:             case READ_FROM_MEMORY: {
 7:                 AtomicLong offset = this.offsetTable.get(mq);
 8:                 if (offset != null) {
 9:                     return offset.get();
10:                 } else if (ReadOffsetType.READ_FROM_MEMORY == type) {
11:                     return -1;
12:                 }
13:             }
14:             case READ_FROM_STORE: {
15:                 OffsetSerializeWrapper offsetSerializeWrapper;
16:                 try {
17:                     offsetSerializeWrapper = this.readLocalOffset();
18:                 } catch (MQClientException e) {
19:                     return -1;
20:                 }
21:                 if (offsetSerializeWrapper != null &amp;&amp; offsetSerializeWrapper.getOffsetTable() != null) {
22:                     AtomicLong offset = offsetSerializeWrapper.getOffsetTable().get(mq);
23:                     if (offset != null) {
24:                         this.updateOffset(mq, offset.get(), false);
25:                         return offset.get();
26:                     }
27:                 }
28:             }
29:             default:
30:                 break;
31:         }
32:     }
33: 
34:     return -1;
35: }
</code></pre>
    <ul>
        <li>第 16 行 ：从 <code>文件</code> 读取消费进度。</li>
    </ul>
    <h4 id="RemoteBrokerOffsetStore-readOffset-…" data-id="heading-55"><a href="#RemoteBrokerOffsetStore-readOffset-…" title="RemoteBrokerOffsetStore#readOffset(…)"></a>RemoteBrokerOffsetStore#readOffset(…)</h4>
    <pre><code> 1: @Override
 2: public long readOffset(final MessageQueue mq, final ReadOffsetType type) {
 3:     if (mq != null) {
 4:         switch (type) {
 5:             case MEMORY_FIRST_THEN_STORE:
 6:             case READ_FROM_MEMORY: {
 7:                 AtomicLong offset = this.offsetTable.get(mq);
 8:                 if (offset != null) {
 9:                     return offset.get();
10:                 } else if (ReadOffsetType.READ_FROM_MEMORY == type) {
11:                     return -1;
12:                 }
13:             }
14:             case READ_FROM_STORE: {
15:                 try {
16:                     long brokerOffset = this.fetchConsumeOffsetFromBroker(mq);
17:                     AtomicLong offset = new AtomicLong(brokerOffset);
18:                     this.updateOffset(mq, offset.get(), false);
19:                     return brokerOffset;
20:                 }
21:                 // No offset in broker
22:                 catch (MQBrokerException e) {
23:                     return -1;
24:                 }
25:                 //Other exceptions
26:                 catch (Exception e) {
27:                     log.warn("fetchConsumeOffsetFromBroker exception, " + mq, e);
28:                     return -2;
29:                 }
30:             }
31:             default:
32:                 break;
33:         }
34:     }
35: 
36:     return -1;
37: }
</code></pre>
    <ul>
        <li>第 16 行 ：从 <code>Broker</code> 读取消费进度。</li>
    </ul>
    <h3 id="OffsetStore-updateOffset-…" data-id="heading-56"><a href="#OffsetStore-updateOffset-…" title="OffsetStore#updateOffset(…)"></a>OffsetStore#updateOffset(…)</h3>
    <p>该方法 <code>RemoteBrokerOffsetStore</code> 与 <code>LocalFileOffsetStore</code> 实现相同。</p>
    <pre><code> 1: @Override
 2: public void updateOffset(MessageQueue mq, long offset, boolean increaseOnly) {
 3:     if (mq != null) {
 4:         AtomicLong offsetOld = this.offsetTable.get(mq);
 5:         if (null == offsetOld) {
 6:             offsetOld = this.offsetTable.putIfAbsent(mq, new AtomicLong(offset));
 7:         }
 8: 
 9:         if (null != offsetOld) {
10:             if (increaseOnly) {
11:                 MixAll.compareAndIncreaseOnly(offsetOld, offset);
12:             } else {
13:                 offsetOld.set(offset);
14:             }
15:         }
16:     }
17: }
</code></pre>
    <h3 id="OffsetStore-persistAll-…" data-id="heading-57"><a href="#OffsetStore-persistAll-…" title="OffsetStore#persistAll(…)"></a>OffsetStore#persistAll(…)</h3>
    <h4 id="LocalFileOffsetStore-persistAll-…" data-id="heading-58"><a href="#LocalFileOffsetStore-persistAll-…" title="LocalFileOffsetStore#persistAll(…)"></a>LocalFileOffsetStore#persistAll(…)</h4>
    <pre><code> 1: @Override
 2: public void persistAll(Set&lt;MessageQueue&gt; mqs) {
 3:     if (null == mqs || mqs.isEmpty())
 4:         return;
 5: 
 6:     OffsetSerializeWrapper offsetSerializeWrapper = new OffsetSerializeWrapper();
 7:     for (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : this.offsetTable.entrySet()) {
 8:         if (mqs.contains(entry.getKey())) {
 9:             AtomicLong offset = entry.getValue();
10:             offsetSerializeWrapper.getOffsetTable().put(entry.getKey(), offset);
11:         }
12:     }
13: 
14:     String jsonString = offsetSerializeWrapper.toJson(true);
15:     if (jsonString != null) {
16:         try {
17:             MixAll.string2File(jsonString, this.storePath);
18:         } catch (IOException e) {
19:             log.error("persistAll consumer offset Exception, " + this.storePath, e);
20:         }
21:     }
22: }
</code></pre>
    <ul>
        <li>说明 ：持久化消费进度。<strong>将消费进度写入文件</strong>。</li>
    </ul>
    <h4 id="RemoteBrokerOffsetStore-persistAll-…" data-id="heading-59"><a href="#RemoteBrokerOffsetStore-persistAll-…" title="RemoteBrokerOffsetStore#persistAll(…)"></a>RemoteBrokerOffsetStore#persistAll(…)</h4>
    <pre><code> 1: @Override
 2: public void persistAll(Set&lt;MessageQueue&gt; mqs) {
 3:     if (null == mqs || mqs.isEmpty())
 4:         return;
 5: 
 6:     // 持久化消息队列
 7:     final HashSet&lt;MessageQueue&gt; unusedMQ = new HashSet&lt;&gt;();
 8:     if (!mqs.isEmpty()) {
 9:         for (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : this.offsetTable.entrySet()) {
10:             MessageQueue mq = entry.getKey();
11:             AtomicLong offset = entry.getValue();
12:             if (offset != null) {
13:                 if (mqs.contains(mq)) {
14:                     try {
15:                         this.updateConsumeOffsetToBroker(mq, offset.get());
16:                         log.info("[persistAll] Group: {} ClientId: {} updateConsumeOffsetToBroker {} {}",
17:                             this.groupName,
18:                             this.mQClientFactory.getClientId(),
19:                             mq,
20:                             offset.get());
21:                     } catch (Exception e) {
22:                         log.error("updateConsumeOffsetToBroker exception, " + mq.toString(), e);
23:                     }
24:                 } else {
25:                     unusedMQ.add(mq);
26:                 }
27:             }
28:         }
29:     }
30: 
31:     // 移除不适用的消息队列
32:     if (!unusedMQ.isEmpty()) {
33:         for (MessageQueue mq : unusedMQ) {
34:             this.offsetTable.remove(mq);
35:             log.info("remove unused mq, {}, {}", mq, this.groupName);
36:         }
37:     }
38: }
</code></pre>
    <ul>
        <li>说明 ：持久化指定消息队列数组的消费进度到 <code>Broker</code>，并移除非指定消息队列。</li>
    </ul>
    <h4 id="MQClientInstance-persistAllConsumerOffset-…" data-id="heading-60"><a href="#MQClientInstance-persistAllConsumerOffset-…" title="MQClientInstance#persistAllConsumerOffset(…)"></a>MQClientInstance#persistAllConsumerOffset(…)</h4>
    <pre><code> 1: private void startScheduledTask() {
 2:     // 定时同步消费进度
 3:     this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
 4: 
 5:         @Override
 6:         public void run() {
 7:             try {
 8:                 MQClientInstance.this.cleanOfflineBroker();
 9:                 MQClientInstance.this.sendHeartbeatToAllBrokerWithLock();
10:             } catch (Exception e) {
11:                 log.error("ScheduledTask sendHeartbeatToAllBroker exception", e);
12:             }
13:         }
14:     }, 1000, this.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);
15: }
</code></pre>
    <ul>
        <li>说明 ：定时进行持久化，默认周期：5000ms。</li>
        <li><strong>重要说明 ：</strong>
            <ul>
                <li><strong>消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。</strong> </li>
                <li><strong>消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。</strong> </li>
                <li><strong>消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。</strong> </li>
            </ul>
        </li>
    </ul>
    <h1 id="9、结尾" data-id="heading-61"><a href="#9、结尾" title="9、结尾"></a>9、结尾</h1>
    <p><img alt="知识星球" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/10/18/166840b9e1e4b9c1?imageView2/0/w/1280/h/960/ignore-error/1" data-width="987" data-height="555" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;987&quot; height=&quot;555&quot;&gt;&lt;/svg&gt;"></p>
    <p>😈可能是本系列最长的一篇文章，如有表达错误和不清晰，请多多见谅。<br>感谢对本系列的阅读、收藏、点赞、分享，特别是翻到结尾。😜真的有丢丢长。</p>
</div><div data-v-41d33d72="" class="footer"><ul data-v-41d33d72="" class="tag-list"><li data-v-41d33d72="" class="item"><a data-v-41d33d72="" href="/tag/Java" class="">Java</a></li></ul><section data-v-41d33d72=""><div data-v-a0f279e6="" data-v-41d33d72="" class="wechat-banner wechat-banner"><img data-v-a0f279e6="" src="https://b-gold-cdn.xitu.io/v3/static/img/backend.58ef824.png" class="wechat-img"></div></section><!----><div data-v-41d33d72="" class="related-entry-list-box"><div data-v-41d33d72="" class="title">相关热门文章</div><ul data-v-41d33d72="" class="related-entry-list"><li data-v-41d33d72="" class="item"><div data-v-9db545a6="" data-v-41d33d72="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-9db545a6="" href="/entry/5bcc88c46fb9a05d3c803037/detail" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-9db545a6="" data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAACgBAMAAACPjaivAAAAElBMVEXi6O3////R3ujj6e/c5u3X4usQB3wbAAABCElEQVR42u3Vy03FQBBE0U6BDBCfPSEQAvlHw44FmvaoEbJLz+dGcORWeUqSJEmSJEmS/trTphoGCAi4CRAQcNMtgfUrQMDjbjgSQMBJgIDTjgyAj3JiQMBJtwTG/2bigfEnBgScdEtg/G8mHhh/YkDASYCAgJsAAQE3AQICbgIEBNwECPgvwJef3mrY2cCvGnY28KOGnQx8rcs7Btb1LYE5E2mAORNpgEEXXgNzJtIAgz7gGpgzkQaYM5EGmPKKtMCciRwBPyuiFvheGS2BQRdeA3Mm0gOfK6QlMGciDTBnIg0w6MJrYM5EGmDQB1wDcybSAHMm0gBTXpEWmDMRSZIkSZIk6cK+AUdTxLnCoi0gAAAAAElFTkSuQmCC" class="lazy thumb thumb loaded" style="background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAACgBAMAAACPjaivAAAAElBMVEXi6O3////R3ujj6e/c5u3X4usQB3wbAAABCElEQVR42u3Vy03FQBBE0U6BDBCfPSEQAvlHw44FmvaoEbJLz+dGcORWeUqSJEmSJEmS/trTphoGCAi4CRAQcNMtgfUrQMDjbjgSQMBJgIDTjgyAj3JiQMBJtwTG/2bigfEnBgScdEtg/G8mHhh/YkDASYCAgJsAAQE3AQICbgIEBNwECPgvwJef3mrY2cCvGnY28KOGnQx8rcs7Btb1LYE5E2mAORNpgEEXXgNzJtIAgz7gGpgzkQaYM5EGmPKKtMCciRwBPyuiFvheGS2BQRdeA3Mm0gOfK6QlMGciDTBnIg0w6MJrYM5EGmDQB1wDcybSAHMm0gBTXpEWmDMRSZIkSZIk6cK+AUdTxLnCoi0gAAAAAElFTkSuQmCC); background-size: cover;"></div><div data-v-9db545a6="" class="info"><div data-v-9db545a6="" class="row title-row"><span data-v-9db545a6="" class="title">详解JVM如何处理异常</span></div><div data-v-9db545a6="" class="row meta-row"><ul data-v-9db545a6="" class="meta-list"><li data-v-9db545a6="" class="meta user"><div data-v-9db545a6="" class="username">技术小黑屋</div></li><li data-v-9db545a6="" class="meta like"><div data-v-9db545a6="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-9db545a6="" class="count">4</div></li><!----></ul></div></div></a></div></li><li data-v-41d33d72="" class="item"><div data-v-9db545a6="" data-v-41d33d72="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-9db545a6="" href="/post/5bcc90866fb9a05cea7fc51e" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-9db545a6="" data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAACgBAMAAACPjaivAAAAElBMVEXi6O3////R3ujj6e/c5u3X4usQB3wbAAABCElEQVR42u3Vy03FQBBE0U6BDBCfPSEQAvlHw44FmvaoEbJLz+dGcORWeUqSJEmSJEmS/trTphoGCAi4CRAQcNMtgfUrQMDjbjgSQMBJgIDTjgyAj3JiQMBJtwTG/2bigfEnBgScdEtg/G8mHhh/YkDASYCAgJsAAQE3AQICbgIEBNwECPgvwJef3mrY2cCvGnY28KOGnQx8rcs7Btb1LYE5E2mAORNpgEEXXgNzJtIAgz7gGpgzkQaYM5EGmPKKtMCciRwBPyuiFvheGS2BQRdeA3Mm0gOfK6QlMGciDTBnIg0w6MJrYM5EGmDQB1wDcybSAHMm0gBTXpEWmDMRSZIkSZIk6cK+AUdTxLnCoi0gAAAAAElFTkSuQmCC" class="lazy thumb thumb loaded" style="background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAACgBAMAAACPjaivAAAAElBMVEXi6O3////R3ujj6e/c5u3X4usQB3wbAAABCElEQVR42u3Vy03FQBBE0U6BDBCfPSEQAvlHw44FmvaoEbJLz+dGcORWeUqSJEmSJEmS/trTphoGCAi4CRAQcNMtgfUrQMDjbjgSQMBJgIDTjgyAj3JiQMBJtwTG/2bigfEnBgScdEtg/G8mHhh/YkDASYCAgJsAAQE3AQICbgIEBNwECPgvwJef3mrY2cCvGnY28KOGnQx8rcs7Btb1LYE5E2mAORNpgEEXXgNzJtIAgz7gGpgzkQaYM5EGmPKKtMCciRwBPyuiFvheGS2BQRdeA3Mm0gOfK6QlMGciDTBnIg0w6MJrYM5EGmDQB1wDcybSAHMm0gBTXpEWmDMRSZIkSZIk6cK+AUdTxLnCoi0gAAAAAElFTkSuQmCC); background-size: cover;"></div><div data-v-9db545a6="" class="info"><div data-v-9db545a6="" class="row title-row"><span data-v-9db545a6="" class="title">2018 年第 42 周沸点看点：开发需求，请用数据说话</span></div><div data-v-9db545a6="" class="row meta-row"><ul data-v-9db545a6="" class="meta-list"><li data-v-9db545a6="" class="meta user"><div data-v-9db545a6="" class="username">沸点日报员</div></li><li data-v-9db545a6="" class="meta like"><div data-v-9db545a6="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-9db545a6="" class="count">3</div></li><!----></ul></div></div></a></div></li><li data-v-41d33d72="" class="item"><div data-v-9db545a6="" data-v-41d33d72="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-9db545a6="" href="/entry/5bca54015188255c63763d6a/detail" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-9db545a6="" data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAACgBAMAAACPjaivAAAAElBMVEXi6O3////R3ujj6e/c5u3X4usQB3wbAAABCElEQVR42u3Vy03FQBBE0U6BDBCfPSEQAvlHw44FmvaoEbJLz+dGcORWeUqSJEmSJEmS/trTphoGCAi4CRAQcNMtgfUrQMDjbjgSQMBJgIDTjgyAj3JiQMBJtwTG/2bigfEnBgScdEtg/G8mHhh/YkDASYCAgJsAAQE3AQICbgIEBNwECPgvwJef3mrY2cCvGnY28KOGnQx8rcs7Btb1LYE5E2mAORNpgEEXXgNzJtIAgz7gGpgzkQaYM5EGmPKKtMCciRwBPyuiFvheGS2BQRdeA3Mm0gOfK6QlMGciDTBnIg0w6MJrYM5EGmDQB1wDcybSAHMm0gBTXpEWmDMRSZIkSZIk6cK+AUdTxLnCoi0gAAAAAElFTkSuQmCC" class="lazy thumb thumb loaded" style="background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAACgBAMAAACPjaivAAAAElBMVEXi6O3////R3ujj6e/c5u3X4usQB3wbAAABCElEQVR42u3Vy03FQBBE0U6BDBCfPSEQAvlHw44FmvaoEbJLz+dGcORWeUqSJEmSJEmS/trTphoGCAi4CRAQcNMtgfUrQMDjbjgSQMBJgIDTjgyAj3JiQMBJtwTG/2bigfEnBgScdEtg/G8mHhh/YkDASYCAgJsAAQE3AQICbgIEBNwECPgvwJef3mrY2cCvGnY28KOGnQx8rcs7Btb1LYE5E2mAORNpgEEXXgNzJtIAgz7gGpgzkQaYM5EGmPKKtMCciRwBPyuiFvheGS2BQRdeA3Mm0gOfK6QlMGciDTBnIg0w6MJrYM5EGmDQB1wDcybSAHMm0gBTXpEWmDMRSZIkSZIk6cK+AUdTxLnCoi0gAAAAAElFTkSuQmCC); background-size: cover;"></div><div data-v-9db545a6="" class="info"><div data-v-9db545a6="" class="row title-row"><span data-v-9db545a6="" class="title">分布式消息队列 RocketMQ 源码分析 —— Message 拉取与消费（上）</span></div><div data-v-9db545a6="" class="row meta-row"><ul data-v-9db545a6="" class="meta-list"><li data-v-9db545a6="" class="meta user"><div data-v-9db545a6="" class="username">Java公众号_芋道源码_每日更新</div></li><li data-v-9db545a6="" class="meta like"><div data-v-9db545a6="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-9db545a6="" class="count">31</div></li><!----></ul></div></div></a></div></li><li data-v-41d33d72="" class="item"><div data-v-9db545a6="" data-v-41d33d72="" st:block="relatedEntry" class="related-entry related-entry"><a data-v-9db545a6="" href="/post/5bc75096f265da0aa94a4043" target="_blank" rel="" st:name="link" class="entry-link"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-9db545a6="" data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAACgBAMAAACPjaivAAAAElBMVEXi6O3////R3ujj6e/c5u3X4usQB3wbAAABCElEQVR42u3Vy03FQBBE0U6BDBCfPSEQAvlHw44FmvaoEbJLz+dGcORWeUqSJEmSJEmS/trTphoGCAi4CRAQcNMtgfUrQMDjbjgSQMBJgIDTjgyAj3JiQMBJtwTG/2bigfEnBgScdEtg/G8mHhh/YkDASYCAgJsAAQE3AQICbgIEBNwECPgvwJef3mrY2cCvGnY28KOGnQx8rcs7Btb1LYE5E2mAORNpgEEXXgNzJtIAgz7gGpgzkQaYM5EGmPKKtMCciRwBPyuiFvheGS2BQRdeA3Mm0gOfK6QlMGciDTBnIg0w6MJrYM5EGmDQB1wDcybSAHMm0gBTXpEWmDMRSZIkSZIk6cK+AUdTxLnCoi0gAAAAAElFTkSuQmCC" class="lazy thumb thumb loaded" style="background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAACgBAMAAACPjaivAAAAElBMVEXi6O3////R3ujj6e/c5u3X4usQB3wbAAABCElEQVR42u3Vy03FQBBE0U6BDBCfPSEQAvlHw44FmvaoEbJLz+dGcORWeUqSJEmSJEmS/trTphoGCAi4CRAQcNMtgfUrQMDjbjgSQMBJgIDTjgyAj3JiQMBJtwTG/2bigfEnBgScdEtg/G8mHhh/YkDASYCAgJsAAQE3AQICbgIEBNwECPgvwJef3mrY2cCvGnY28KOGnQx8rcs7Btb1LYE5E2mAORNpgEEXXgNzJtIAgz7gGpgzkQaYM5EGmPKKtMCciRwBPyuiFvheGS2BQRdeA3Mm0gOfK6QlMGciDTBnIg0w6MJrYM5EGmDQB1wDcybSAHMm0gBTXpEWmDMRSZIkSZIk6cK+AUdTxLnCoi0gAAAAAElFTkSuQmCC); background-size: cover;"></div><div data-v-9db545a6="" class="info"><div data-v-9db545a6="" class="row title-row"><span data-v-9db545a6="" class="title">聊一聊 RestTemplate</span></div><div data-v-9db545a6="" class="row meta-row"><ul data-v-9db545a6="" class="meta-list"><li data-v-9db545a6="" class="meta user"><div data-v-9db545a6="" class="username">glmapper</div></li><li data-v-9db545a6="" class="meta like"><div data-v-9db545a6="" class="icon icon-likes iconfont icon-xlcollection"></div><div data-v-9db545a6="" class="count">28</div></li><!----></ul></div></div></a></div></li></ul></div></div></article><div data-v-4f97d566="" data-v-41d33d72="" class="comment-list-box" id="comment-box" data-v-3f216172=""><div data-v-4f97d566="" class="title">评论</div><div data-v-1cbbd4f0="" data-v-4f97d566="" class="comment-form comment-form"><div data-v-1cbbd4f0="" class="avatar-box"><div data-v-b2db8566="" data-v-1b9df826="" data-v-1cbbd4f0="" data-src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjM2cHgiIGhlaWdodD0iMzZweCIgdmlld0JveD0iMCAwIDM2IDM2IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOnNrZXRjaD0iaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zIj4KICAgIDwhLS0gR2VuZXJhdG9yOiBTa2V0Y2ggMy4zLjMgKDEyMDgxKSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5kZWZhdWx0X2dyYXZhdGFyPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc2tldGNoOnR5cGU9Ik1TUGFnZSI+CiAgICAgICAgPGcgaWQ9ImRlZmF1bHRfZ3JhdmF0YXIiIHNrZXRjaDp0eXBlPSJNU0FydGJvYXJkR3JvdXAiPgogICAgICAgICAgICA8ZyBpZD0iUmVjdGFuZ2xlLTIxMC0rLUltcG9ydGVkLUxheWVycy1Db3B5LUNvcHkiIHNrZXRjaDp0eXBlPSJNU0xheWVyR3JvdXAiPgogICAgICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0yMTAiIGZpbGw9IiNEOEQ4RDgiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiIHg9IjAiIHk9IjAiIHdpZHRoPSIzNiIgaGVpZ2h0PSIzNiI+PC9yZWN0PgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTI3Ljg2OTAzMjEsMjYuODUzNjU2OCBMOCwyNi44NTM2NTY4IEM4LDI1Ljg0OTQ1MTQgOC40NzE4MjUsMjQuMTEwOTQ2NiAxMS41MTg5MDQ1LDIyLjM4ODMxNzYgQzEyLjE1Nzg5NiwyMi4wMjcxMjEzIDE1LjM0Mzk1MTIsMjAuMDk2MTA5OCAxNS42MTU5Njc3LDE5LjYzNzE3MjEgQzE1LjkyNDU4MjgsMTkuMTE3MjA4MSAxNi4wMTA2Mzg5LDE4LjQ3NjE4MzcgMTUuNDIwMTE1OCwxNy41MzI1MDg1IEMxNS4zNzI2MzY2LDE3LjQ1NjEwMTYgMTQuNDM0OTIxNSwxNi4wMDgzMzkxIDE0LjE0NTEwMDMsMTUuMDMwNDI5NyBDMTMuOTQwMzQ2LDE0LjMzODMwMiAxMy45MTc1OTU1LDEzLjU0NTQ1NjEgMTMuOTE3NTk1NSwxMi43MTM0MTQ0IEMxMy45MTc1OTU1LDkuODM2MjQ3MDIgMTUuNzIyMzAxNCw4IDE3Ljk0ODM4NTYsOCBDMjAuMTc0NDY5OSw4IDIxLjk3OTE3NTgsOS44MzYyNDcwMiAyMS45NzkxNzU4LDEyLjcxMzQxNDQgQzIxLjk3OTE3NTgsMTMuMzk5MDkyMiAyMS45NjYzMTY4LDE0LjA1NTk5MzMgMjEuODQ3MTI0MSwxNC42NTM4NTI3IEMyMS42Mzk4OTcsMTUuNjkwMzA3NyAyMC43NzU4NzM2LDE3LjAwNTU5ODQgMjAuNTg4NDI5NSwxNy4zMzA1NzU5IEMyMC41NDM5MTc3LDE3LjQwNzQ3OSAyMC41MDc4MTM3LDE3LjQ2NzUxMyAyMC40ODUwNjMzLDE3LjUwMTI1MTEgQzIwLjA3OTAxNjgsMTguMTA3MDQ4OSAxOS45NjI3OTE2LDE4LjU1MzU4MjkgMjAuMDAwODczOSwxOC45MTUyNzU1IEMyMC4wNDQzOTY1LDE5LjMyODU2NzUgMjAuMzEzOTQwMSwxOS42MTYzMzM4IDIwLjY2NzA2NywxOS44NTQ0ODUzIEMyMS4wMzQ1MzY2LDIwLjEwMjA2MzYgMjQuMDExODgxLDIyLjE0OTY3IDI0LjM3Nzg2NjgsMjIuMzg4MzE3NiBDMjYuODcxNTE2MywyNC4wMTY2NzgzIDI3Ljg2OTAzMjEsMjUuNjA2MzM4NSAyNy44NjkwMzIxLDI2Ljg1MzY1NjggTDI3Ljg2OTAzMjEsMjYuODUzNjU2OCBaIiBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHkiIGZpbGw9IiNGRkZGRkYiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+" class="lazy avatar avatar" title="" style="background-image: none;"></div></div><div data-v-1cbbd4f0="" class="form-box"><div data-v-1cbbd4f0="" class="input-box"><div data-v-1cbbd4f0="" contenteditable="true" spellcheck="false" placeholder="输入评论..." class="rich-input empty"><br data-v-1cbbd4f0=""></div><!----></div><!----></div><input data-v-1cbbd4f0="" type="file" class="hidden"></div><!----><!----></div></div><div data-v-41d33d72="" data-v-3f216172="" st:block="aside" class="entry-public-aside"><div data-v-70a2cd6d="" data-v-fb64097a="" data-v-41d33d72="" class="sidebar-block app-download-sidebar-block shadow"><!----><div data-v-70a2cd6d="" class="block-body"><a data-v-fb64097a="" data-v-70a2cd6d="" class="app-link" href="https://juejin.im/app" target="_blank"><img data-v-fb64097a="" data-v-70a2cd6d="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAEx0lEQVR4Xu2c7XbbMAxD0zffm2cna7NlbuwLkJJjN+hfUiQF8ENS0nxcr9frJX+HQeDjRsjHr/3juT74fOb/Ub6MTomX7C9tdv2NQjCEfCEZQlIhT4sqFZIK+UTA7fFuj+7a7653473rr1bIVk91ndHQVob01hAm+xQvrSc52Sf5o/0QcrlcCHCSE+AkDyELhAhwkhPgJLcJmd1SKvZpk26Lc/W7M2ZtvdSyKoBRwM6Mqvh3AXb1aX+UMCEE7j0hxHiuSYUMuCdQSe/dsqiFpEKaFdJ9e+omBCUcJcCPmyEhhChfyCmDRmboMjRl5oz0r/hTW+Ihjr2VDakbVPPIrThKOPJ76Ja1ByEEYAgx7wXVjLuvCyHGB1CpkH/p9jYz5EdVCLULktNrKcmVU5RzaqJ49/Znv/a6G3A3FELMlhVCviMwsiKlCumSQOudnl4Z+l37tJ72V5Wf4lsn1NJeIa8CTutCSPEzdQK2Kg8hIeQzd6hHk5wykNZ35eS/Kv9TIdXFo9ZVZgD5HnkKIl8j5SFkJJoDbIWQASCONFEe6u5z9TJo6uEjN/nMVjd+iq9q/7SEVDd8B7K7PoQsEOgC2l0fQkLIdg6cfQbsHb/q7+kpS3nMUx0869mK/dEtwW1Ro/en2gshg55OCHCS3xMwhLwrIdSCunLKQJLP9q/aH1IhS2fKjCCAOj2fNj/77ayz/xDyxR4lCJHsrl/TDyEh5BOBURmlHqvJH8mpQlz5rhXiBuf2XLJPM6KyntaQXP18ZkrLouC6hwCyH0IIIZCnQv4BNKRCFECXnLg929Xf8kf5U9kP2VSP8UM+MaxswAXY1e8QMrulbtkPIZTaK08rswgPIWckhE4tZ29ZI/anHmtv/G/hJVUIBaz0XHWoPbvoURK78bnxdu0r/u46IaT4/O5URAhZPM10K2z3CtljBhAorrx7DCZ/s+2v+R/yvSzKoArhrwbMnXkUr3oxDiErSIYQM8Vmt5QQYhIyW31Pwr/90+fszbn2R8wcAtQ5tirxOPa28JDuIS6gXX0FAPIRQgghQ/72hCgAUMapxzqDl6mq7n7cYNxDwV1fPva6G3D1XULdDbv2XQK27CtPJyFk8O91hZCNXzWd0YLdinEr+O0rxAXY1a+27EMce+ktzAVDqRCy6dwrKH5HHkIKb1nOkL7phhDjV7PXKuWlFTKixKkFuMdOtwe7+hQv2SN51b58DyEHrrybgc4xU2kxeybMVjwhRJghzgyotMBvr72vbllUXUp8Myvu7QhRACfSqKeTfM+Whd/LogwgMEhO9iuEVG/Ca8fQ0TPJje/uX/plawKc5CHkf4RSIc1/oesmnHPKkyqk21JmVAiB5M4E156rr86wQxDibm5GgrgxuPohZIGYCogLtKqv+k+FqIg29X4UIZUWdbQZovJ5igqpHAq6N/fqPUIFfi1hQojweYVzbA0hBUAVgN+6QiozQh2S1Yx91Qw6RMs6GyEzKyyEiCXktjBX33pcnJHB3ZbTXS/y8FfNBdjVPz0hLqB7608lpLuZ7j1iRoXOHtrOPegxFmmGhBAfgRDSfEwcPZOGE+LnhLeCACC55+312upMOcTXgLozRrkXuDOjmuE3P7SfrXhDSAFAqrcOIb8BQLPhcIRSNNMAAAAASUVORK5CYII=" class="qr-img"><div data-v-fb64097a="" data-v-70a2cd6d="" class="content-box"><div data-v-fb64097a="" data-v-70a2cd6d="" class="headline">下载掘金客户端</div><div data-v-fb64097a="" data-v-70a2cd6d="" class="desc">一个帮助开发者成长的社区</div></div><!----></a></div></div><div data-v-70a2cd6d="" data-v-1988842d="" data-v-41d33d72="" class="sidebar-block wechat-sidebar-block pure"><div data-v-a0f279e6="" data-v-1988842d="" class="wechat-banner" data-v-70a2cd6d=""><img data-v-a0f279e6="" src="https://b-gold-cdn.xitu.io/v3/static/img/backend.ba44b94.png" class="wechat-img"></div><!----></div><div data-v-1f85cb5f="" data-v-17a8ac96="" data-v-41d33d72="" class="index-book-collect" place="entry" category="5562b419e4b00c57d9b94ae2"><div data-v-1f85cb5f="" class="header"><div data-v-1f85cb5f="" class="title">掘金小册</div><div data-v-1f85cb5f="" class="controllers"><div data-v-1f85cb5f="" class="arrow icon ion-chevron-left"></div><div data-v-1f85cb5f="" class="arrow icon ion-chevron-right"></div></div></div><div data-v-1f85cb5f="" class="slide-book transition--next"><div data-v-133abdc5="" data-v-1f85cb5f="" class="slide-book-list item"><a data-v-133abdc5="" href="/book/5b7be023e51d4538850305d0" class="item"><div data-v-133abdc5="" class="poster"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-133abdc5="" data-src="https://user-gold-cdn.xitu.io/2018/9/18/165eb6f3cb9eb04f?imageView2/1/w/104/h/144/q/95/interlace/1" class="lazy thumb poster-img loaded" style="background-image: url(https://user-gold-cdn.xitu.io/2018/9/18/165eb6f3cb9eb04f?imageView2/1/w/104/h/144/q/95/interlace/1); background-size: cover;"></div></div><div data-v-133abdc5="" class="content-text"><div data-v-133abdc5="" class="title">微信小游戏开发入门：从 0 到 1 实现井字棋游戏</div><div data-v-133abdc5="" class="price"><div data-v-133abdc5="" class="new">新人价 ￥4.95</div><div data-v-133abdc5="" class="delete">￥9.9</div></div></div></a><a data-v-133abdc5="" href="/book/5a157c155188254a701eb3c1" class="item"><div data-v-133abdc5="" class="poster"><div data-v-b2db8566="" data-v-009ea7bb="" data-v-133abdc5="" data-src="https://user-gold-cdn.xitu.io/2017/12/18/160691fc2995dbf9?imageView2/1/w/104/h/144/q/95/interlace/1" class="lazy thumb poster-img loaded" style="background-image: url(https://user-gold-cdn.xitu.io/2017/12/18/160691fc2995dbf9?imageView2/1/w/104/h/144/q/95/interlace/1); background-size: cover;"></div></div><div data-v-133abdc5="" class="content-text"><div data-v-133abdc5="" class="title">基于 Python 实现微信公众号爬虫</div><div data-v-133abdc5="" class="price"><div data-v-133abdc5="" class="new">新人价 ￥9.95</div><div data-v-133abdc5="" class="delete">￥19.9</div></div></div></a></div></div><div data-v-1f85cb5f="" class="book-newuser"><div data-v-1f85cb5f="" class="newuser-title"><span data-v-1f85cb5f="">新人专享好礼</span></div><div data-v-1f85cb5f="" class="giftbag"><img data-v-1f85cb5f="" src="https://b-gold-cdn.xitu.io/v3/static/img/45.b99ea03.svg"><div data-v-1f85cb5f="" class="content-text"><div data-v-1f85cb5f="" class="title">送你<span data-v-1f85cb5f="" class="highlight">45元</span>买小册</div><div data-v-1f85cb5f="" class="btn-box"><div data-v-1f85cb5f="" class="btn-giftbag">立即领取</div></div></div></div></div></div><!----><div data-v-70a2cd6d="" data-v-f6632f66="" data-v-41d33d72="" class="sidebar-block related-entry-sidebar-block sticky-section shadow" st:block="relatedEntrySidebarBlock" data-v-3f216172=""><div data-v-70a2cd6d="" class="block-title">相关文章</div><div data-v-70a2cd6d="" class="block-body"><div data-v-f6632f66="" data-v-70a2cd6d="" class="entry-list"><a data-v-f6632f66="" href="/entry/5bcc88c46fb9a05d3c803037" target="_blank" rel="" st:name="link" class="item" data-v-70a2cd6d=""><div data-v-f6632f66="" class="entry-title">详解JVM如何处理异常</div><div data-v-f6632f66="" class="entry-meta-box"><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik00LjIzNCA2LjY5M3Y3LjI0M0gyLjg4MWMtLjQ4NiAwLS44ODEtLjQ5Mi0uODgxLTEuMDk1VjcuODc1YzAtLjYzLjQxMi0xLjE4Mi44OC0xLjE4MmgxLjM1NHptMy42ODgtMy43QzguMDEgMi40MDQgOC40OSAxLjk5IDkuMDE4IDJjLjc1NC4wMTUgMS4yMDQuNjYzIDEuMzYuOTgzLjI4NC41ODUuMjkyIDEuNTQ5LjA5NyAyLjE2Ny0uMTc3LjU2LS41ODYgMS4yOTYtLjU4NiAxLjI5NmgzLjA2NmMuMzI0IDAgLjYyNS4xNjQuODI2LjQ0OS4yMDQuMjkuMjcuNjY4LjE3OCAxLjAxMWwtMS4zODcgNS4xODNjLS4xMjYuNDk5LS41NDQuODQ3LTEuMDE2Ljg0N0g1LjUzVjYuNjkzYzEuMzg1LS4zMDkgMi4yMzYtMi42MzIgMi4zOTItMy43eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">4</span></div><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik0yIDR2OC4wMzhoNC40NDRMMTEuMTExIDE1di0yLjk2MkgxNFY0eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">0</span></div></div></a><a data-v-f6632f66="" href="/post/5bcc90866fb9a05cea7fc51e" target="_blank" rel="" st:name="link" class="item" data-v-70a2cd6d=""><div data-v-f6632f66="" class="entry-title">2018 年第 42 周沸点看点：开发需求，请用数据说话</div><div data-v-f6632f66="" class="entry-meta-box"><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik00LjIzNCA2LjY5M3Y3LjI0M0gyLjg4MWMtLjQ4NiAwLS44ODEtLjQ5Mi0uODgxLTEuMDk1VjcuODc1YzAtLjYzLjQxMi0xLjE4Mi44OC0xLjE4MmgxLjM1NHptMy42ODgtMy43QzguMDEgMi40MDQgOC40OSAxLjk5IDkuMDE4IDJjLjc1NC4wMTUgMS4yMDQuNjYzIDEuMzYuOTgzLjI4NC41ODUuMjkyIDEuNTQ5LjA5NyAyLjE2Ny0uMTc3LjU2LS41ODYgMS4yOTYtLjU4NiAxLjI5NmgzLjA2NmMuMzI0IDAgLjYyNS4xNjQuODI2LjQ0OS4yMDQuMjkuMjcuNjY4LjE3OCAxLjAxMWwtMS4zODcgNS4xODNjLS4xMjYuNDk5LS41NDQuODQ3LTEuMDE2Ljg0N0g1LjUzVjYuNjkzYzEuMzg1LS4zMDkgMi4yMzYtMi42MzIgMi4zOTItMy43eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">3</span></div><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik0yIDR2OC4wMzhoNC40NDRMMTEuMTExIDE1di0yLjk2MkgxNFY0eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">0</span></div></div></a><a data-v-f6632f66="" href="/entry/5bca54015188255c63763d6a" target="_blank" rel="" st:name="link" class="item" data-v-70a2cd6d=""><div data-v-f6632f66="" class="entry-title">分布式消息队列 RocketMQ 源码分析 —— Message 拉取与消费（上）</div><div data-v-f6632f66="" class="entry-meta-box"><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik00LjIzNCA2LjY5M3Y3LjI0M0gyLjg4MWMtLjQ4NiAwLS44ODEtLjQ5Mi0uODgxLTEuMDk1VjcuODc1YzAtLjYzLjQxMi0xLjE4Mi44OC0xLjE4MmgxLjM1NHptMy42ODgtMy43QzguMDEgMi40MDQgOC40OSAxLjk5IDkuMDE4IDJjLjc1NC4wMTUgMS4yMDQuNjYzIDEuMzYuOTgzLjI4NC41ODUuMjkyIDEuNTQ5LjA5NyAyLjE2Ny0uMTc3LjU2LS41ODYgMS4yOTYtLjU4NiAxLjI5NmgzLjA2NmMuMzI0IDAgLjYyNS4xNjQuODI2LjQ0OS4yMDQuMjkuMjcuNjY4LjE3OCAxLjAxMWwtMS4zODcgNS4xODNjLS4xMjYuNDk5LS41NDQuODQ3LTEuMDE2Ljg0N0g1LjUzVjYuNjkzYzEuMzg1LS4zMDkgMi4yMzYtMi42MzIgMi4zOTItMy43eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">31</span></div><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik0yIDR2OC4wMzhoNC40NDRMMTEuMTExIDE1di0yLjk2MkgxNFY0eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">0</span></div></div></a><a data-v-f6632f66="" href="/post/5bc75096f265da0aa94a4043" target="_blank" rel="" st:name="link" class="item" data-v-70a2cd6d=""><div data-v-f6632f66="" class="entry-title">聊一聊 RestTemplate</div><div data-v-f6632f66="" class="entry-meta-box"><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik00LjIzNCA2LjY5M3Y3LjI0M0gyLjg4MWMtLjQ4NiAwLS44ODEtLjQ5Mi0uODgxLTEuMDk1VjcuODc1YzAtLjYzLjQxMi0xLjE4Mi44OC0xLjE4MmgxLjM1NHptMy42ODgtMy43QzguMDEgMi40MDQgOC40OSAxLjk5IDkuMDE4IDJjLjc1NC4wMTUgMS4yMDQuNjYzIDEuMzYuOTgzLjI4NC41ODUuMjkyIDEuNTQ5LjA5NyAyLjE2Ny0uMTc3LjU2LS41ODYgMS4yOTYtLjU4NiAxLjI5NmgzLjA2NmMuMzI0IDAgLjYyNS4xNjQuODI2LjQ0OS4yMDQuMjkuMjcuNjY4LjE3OCAxLjAxMWwtMS4zODcgNS4xODNjLS4xMjYuNDk5LS41NDQuODQ3LTEuMDE2Ljg0N0g1LjUzVjYuNjkzYzEuMzg1LS4zMDkgMi4yMzYtMi42MzIgMi4zOTItMy43eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">28</span></div><div data-v-f6632f66="" class="entry-meta"><img data-v-f6632f66="" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICAgIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgxNnYxNkgweiIvPgogICAgICAgIDxwYXRoIGZpbGw9IiNCMkJBQzIiIGQ9Ik0yIDR2OC4wMzhoNC40NDRMMTEuMTExIDE1di0yLjk2MkgxNFY0eiIvPgogICAgPC9nPgo8L3N2Zz4K" class="icon"><span data-v-f6632f66="" class="count">0</span></div></div></a></div></div></div></div></div><div data-v-2febaf4d="" data-v-41d33d72="" class="article-suspended-panel article-suspended-panel" data-v-3f216172=""><div data-v-2febaf4d="" badge="22" class="like-btn panel-btn like-adjust with-badge"></div><div data-v-2febaf4d="" badge="0" class="comment-btn panel-btn comment-adjust"></div><div data-v-2febaf4d="" class="collect-btn panel-btn"><!----></div><div data-v-2febaf4d="" class="share-title">分享</div><div data-v-2febaf4d="" class="weibo-btn share-btn panel-btn"></div><div data-v-2febaf4d="" class="qq-btn share-btn panel-btn"></div><div data-v-2febaf4d="" class="wechat-btn share-btn panel-btn"><img data-v-2febaf4d="" src="" class="wechat-qr-code-img shadow" style="display: none;"></div></div><div data-v-f0e3c22e="" data-v-41d33d72="" class="image-viewer-box" data-v-3f216172=""><!----></div><div data-v-00a4671b="" data-v-41d33d72="" st:block="mobileBottomBar" class="mobile-bottom-bar" data-v-3f216172=""><div data-v-00a4671b="" class="bar-container"><a data-v-00a4671b="" href="https://juejin.im/about" class="left"><img data-v-00a4671b="" src="https://b-gold-cdn.xitu.io/images/logo-bold.svg"><span data-v-00a4671b="">一个帮助开发者成长的社区</span></a><a data-v-00a4671b="" st:name="openInAppBtn" class="button">打开应用<div data-v-00a4671b="" class="pop-up" style="display: none;"><a data-v-00a4671b="" class="pop-up-content"></a></div></a></div></div></main></div><div data-v-19078e6d="" data-v-6ede48a3="" class="recommend-box"><div data-v-19078e6d="" class="extension"><div data-v-19078e6d="" data-growing-container="true" data-growing-title="掘金插件" class="link"><div data-v-19078e6d="" class="title">掘金浏览器插件 - 下载插件，送你<span data-v-19078e6d="" class="price">45元</span>买小册</div></div><div data-v-19078e6d="" class="ion-close"></div></div><!----></div></div>
      
      <script type="text/javascript" src="https://b-gold-cdn.xitu.io/v3/static/js/manifest.20254fa563d3539b68bf.js"></script><script type="text/javascript" src="https://b-gold-cdn.xitu.io/v3/static/js/vendor.e6fd81aa1499049a5bee.js"></script><script type="text/javascript" src="https://b-gold-cdn.xitu.io/v3/static/js/app.a99a1e8180beec940a3f.js"></script>
    </body></html>